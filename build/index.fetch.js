this.onerror = function(e) {
  console.error(e);
}


function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
function _emscripten_get_heap_size() {
      return HEAP8.length;
    }
function _emscripten_resize_heap(requestedSize) {
      var oldSize = _emscripten_get_heap_size();
      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.
      if (requestedSize <= oldSize) {
        return false;
      }
  
  
      var PAGE_MULTIPLE = 65536;
      var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.
  
      if (requestedSize > LIMIT) {
        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + LIMIT + ' bytes!');
        return false;
      }
  
      var MIN_TOTAL_MEMORY = 16777216;
      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.
  
      // TODO: see realloc_buffer - for PTHREADS we may want to decrease these jumps
      while (newSize < requestedSize) { // Keep incrementing the heap size as long as it's less than what is requested.
        if (newSize <= 536870912) {
          newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...
        } else {
          // ..., but after that, add smaller increments towards 2GB, which we cannot reach
          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
          if (newSize === oldSize) {
            warnOnce('Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ' + HEAP8.length);
          }
        }
      }
  
      // A limit was set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow). That is,
      // if we are at say 64MB, and the max is 100MB, then we should *not* try to
      // grow 64->128MB which is the default behavior (doubling), as 128MB will
      // fail because of the max limit. Instead, we should only try to grow
      // 64->100MB in this example, which has a chance of succeeding (but may
      // still fail for another reason, of actually running out of memory).
      newSize = Math.min(newSize, 1073741824);
      if (newSize == oldSize) {
        err('Failed to grow the heap from ' + oldSize + ', as we reached the WASM_MEM_MAX limit (' + 1073741824 + ') set during compilation');
        return false;
      }
  
      var start = Date.now();
  
      if (!emscripten_realloc_buffer(newSize)) {
        err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');
        return false;
      }
  
      // Updating the views here is not strictly necessary, since we instrument each load and store
      // to do so, but doing it here is clean and may be more efficient (avoid surprising the JIT
      // later by taking a never-taken branch).
      updateGlobalBufferViews();
  
  
  
      return true;
    }
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}
function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;

    var str = '';
    while (!(idx >= endIdx)) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = u8Array[idx++];
      // If not building with TextDecoder enabled, we don't know the string length, so scan for \0 byte.
      // If building with TextDecoder, we know exactly at what byte index the string ends, so checking for nulls here would be redundant.
      if (!u0) return str;
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = u8Array[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = u8Array[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  return str;
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
function _emscripten_is_main_runtime_thread() {
    return __pthread_is_main_runtime_thread|0; // Semantically the same as testing "!ENVIRONMENT_IS_PTHREAD" outside the asm.js scope
}
function _emscripten_futex_wait(addr, val, timeout) {
      if (addr <= 0 || addr > HEAP8.length || addr&3 != 0) return -22;
  //    dump('futex_wait addr:' + addr + ' by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
      if (ENVIRONMENT_IS_WORKER) {
        var ret = Atomics.wait(HEAP32, addr >> 2, val, timeout);
  //    dump('futex_wait done by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
        if (ret === 'timed-out') return -110;
        if (ret === 'not-equal') return -11;
        if (ret === 'ok') return 0;
        throw 'Atomics.wait returned an unexpected value ' + ret;
      } else {
        // Atomics.wait is not available in the main browser thread, so simulate it via busy spinning.
        var loadedVal = Atomics.load(HEAP32, addr >> 2);
        if (val != loadedVal) return -11;
  
        var tNow = performance.now();
        var tEnd = tNow + timeout;
  
  
        // Register globally which address the main thread is simulating to be waiting on. When zero, main thread is not waiting on anything,
        // and on nonzero, the contents of address pointed by __main_thread_futex_wait_address tell which address the main thread is simulating its wait on.
        Atomics.store(HEAP32, __main_thread_futex_wait_address >> 2, addr);
        var ourWaitAddress = addr; // We may recursively re-enter this function while processing queued calls, in which case we'll do a spurious wakeup of the older wait operation.
        while (addr == ourWaitAddress) {
          tNow = performance.now();
          if (tNow > tEnd) {
            return -110;
          }
          _emscripten_main_thread_process_queued_calls(); // We are performing a blocking loop here, so must pump any pthreads if they want to perform operations that are proxied.
          addr = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2); // Look for a worker thread waking us up.
        }
        return 0;
      }
    }
function _malloc($0) {
 $0 = $0|0;
 var $$0$i = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i16$i = 0, $$0169$i = 0, $$0170$i = 0, $$0171$i = 0, $$0193 = 0, $$0195 = 0, $$02014$i$i = 0, $$0202$lcssa$i$i = 0, $$02023$i$i = 0, $$0206$i$i = 0, $$0207$i$i = 0, $$024364$i = 0, $$0259$i$i = 0, $$02604$i$i = 0, $$0261$lcssa$i$i = 0, $$02613$i$i = 0, $$0267$i$i = 0;
 var $$0268$i$i = 0, $$0318$i = 0, $$032012$i = 0, $$0321$lcssa$i = 0, $$032111$i = 0, $$0323$i = 0, $$0329$i = 0, $$0335$i = 0, $$0336$i = 0, $$0338$i = 0, $$0339$i = 0, $$0344$i = 0, $$1 = 0, $$1174$i = 0, $$1174$i$be = 0, $$1174$i$ph = 0, $$1176$i = 0, $$1176$i$be = 0, $$1176$i$ph = 0, $$124463$i = 0;
 var $$1263$i$i = 0, $$1263$i$i$be = 0, $$1263$i$i$ph = 0, $$1265$i$i = 0, $$1265$i$i$be = 0, $$1265$i$i$ph = 0, $$1319$i = 0, $$1324$i = 0, $$1340$i = 0, $$1346$i = 0, $$1346$i$be = 0, $$1346$i$ph = 0, $$1350$i = 0, $$1350$i$be = 0, $$1350$i$ph = 0, $$2 = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2331$i = 0;
 var $$3$i = 0, $$3$i$i = 0, $$3$i196 = 0, $$3$i196210 = 0, $$3229$i = 0, $$3235$i = 0, $$3326$i = 0, $$3348$i = 0, $$4$lcssa$i = 0, $$415$i = 0, $$415$i$ph = 0, $$4230$i = 0, $$4236$i = 0, $$4327$lcssa$i = 0, $$432714$i = 0, $$432714$i$ph = 0, $$4333$i = 0, $$533413$i = 0, $$533413$i$ph = 0, $$7$i = 0;
 var $$7239$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i17$i = 0, $$pre$i201 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i18$iZ2D = 0, $$pre$phi$i202Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink319 = 0, $$sink320 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0;
 var $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0;
 var $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0;
 var $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0;
 var $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0;
 var $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0;
 var $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0;
 var $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0;
 var $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0;
 var $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0;
 var $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0;
 var $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0;
 var $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0;
 var $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0;
 var $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0;
 var $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0;
 var $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0;
 var $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0;
 var $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0;
 var $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0;
 var $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0;
 var $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0;
 var $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0;
 var $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0;
 var $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0;
 var $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0;
 var $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0;
 var $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0;
 var $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0;
 var $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0;
 var $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0;
 var $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0;
 var $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0;
 var $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0;
 var $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0;
 var $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0;
 var $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0;
 var $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0;
 var $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0;
 var $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0;
 var $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0;
 var $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0, $833 = 0;
 var $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0;
 var $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0;
 var $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0;
 var $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0, $905 = 0;
 var $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0;
 var $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0;
 var $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0;
 var $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0;
 var $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0, $996 = 0;
 var $997 = 0, $998 = 0, $999 = 0, $cond$i = 0, $cond$i$i = 0, $cond$i200 = 0, $or$cond$i = 0, $or$cond$i205 = 0, $or$cond1$i = 0, $or$cond1$i203 = 0, $or$cond11$i = 0, $or$cond2$i = 0, $or$cond43$i = 0, $or$cond5$i = 0, $or$cond6$i = 0, $or$cond7$i = 0, $or$cond8$i = 0, $or$cond9$i = 0, $spec$select$i = 0, $spec$select$i198 = 0;
 var $spec$select1$i = 0, $spec$select10$i = 0, $spec$select2$i = 0, $spec$select4$i = 0, $spec$select42$i = 0, $spec$select9$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abortStackOverflow(16|0);
 $1 = sp + 4|0;
 $2 = sp;
 $3 = HEAP32[6835]|0;
 $4 = ($3|0)==(0);
 if ($4) {
  (___pthread_mutex_lock(27364)|0);
  $5 = HEAP32[6835]|0;
  $6 = ($5|0)==(0);
  if ($6) {
   HEAP32[(27348)>>2] = 4096;
   HEAP32[(27344)>>2] = 4096;
   HEAP32[(27352)>>2] = -1;
   HEAP32[(27356)>>2] = -1;
   HEAP32[(27360)>>2] = 2;
   HEAP32[(27836)>>2] = 2;
   $7 = (_pthread_mutexattr_init($1)|0);
   $8 = ($7|0)==(0);
   if ($8) {
    $9 = (_pthread_mutex_init((27840),$1)|0);
    $10 = ($9|0)==(0);
    if ($10) {
    }
   }
   $11 = $2;
   $12 = $11 & -16;
   $13 = $12 ^ 1431655768;
   Atomics_store(HEAP32,6835,$13)|0;
  }
  (___pthread_mutex_unlock(27364)|0);
 }
 $14 = HEAP32[(27836)>>2]|0;
 $15 = $14 & 2;
 $16 = ($15|0)==(0);
 if (!($16)) {
  $17 = (___pthread_mutex_lock((27840))|0);
  $18 = ($17|0)==(0);
  if (!($18)) {
   $$1 = 0;
   STACKTOP = sp;return ($$1|0);
  }
 }
 $19 = ($0>>>0)<(245);
 do {
  if ($19) {
   $20 = ($0>>>0)<(11);
   $21 = (($0) + 11)|0;
   $22 = $21 & -8;
   $23 = $20 ? 16 : $22;
   $24 = $23 >>> 3;
   $25 = HEAP32[6848]|0;
   $26 = $25 >>> $24;
   $27 = $26 & 3;
   $28 = ($27|0)==(0);
   if (!($28)) {
    $29 = $26 & 1;
    $30 = $29 ^ 1;
    $31 = (($30) + ($24))|0;
    $32 = $31 << 1;
    $33 = (27432 + ($32<<2)|0);
    $34 = ((($33)) + 8|0);
    $35 = HEAP32[$34>>2]|0;
    $36 = ((($35)) + 8|0);
    $37 = HEAP32[$36>>2]|0;
    $38 = ($37|0)==($33|0);
    if ($38) {
     $39 = 1 << $31;
     $40 = $39 ^ -1;
     $41 = $25 & $40;
     HEAP32[6848] = $41;
    } else {
     $42 = ((($37)) + 12|0);
     HEAP32[$42>>2] = $33;
     HEAP32[$34>>2] = $37;
    }
    $43 = $31 << 3;
    $44 = $43 | 3;
    $45 = ((($35)) + 4|0);
    HEAP32[$45>>2] = $44;
    $46 = (($35) + ($43)|0);
    $47 = ((($46)) + 4|0);
    $48 = HEAP32[$47>>2]|0;
    $49 = $48 | 1;
    HEAP32[$47>>2] = $49;
    $$2 = $36;
    break;
   }
   $50 = HEAP32[(27400)>>2]|0;
   $51 = ($23>>>0)>($50>>>0);
   if ($51) {
    $52 = ($26|0)==(0);
    if (!($52)) {
     $53 = $26 << $24;
     $54 = 2 << $24;
     $55 = (0 - ($54))|0;
     $56 = $54 | $55;
     $57 = $53 & $56;
     $58 = (0 - ($57))|0;
     $59 = $57 & $58;
     $60 = (($59) + -1)|0;
     $61 = $60 >>> 12;
     $62 = $61 & 16;
     $63 = $60 >>> $62;
     $64 = $63 >>> 5;
     $65 = $64 & 8;
     $66 = $65 | $62;
     $67 = $63 >>> $65;
     $68 = $67 >>> 2;
     $69 = $68 & 4;
     $70 = $66 | $69;
     $71 = $67 >>> $69;
     $72 = $71 >>> 1;
     $73 = $72 & 2;
     $74 = $70 | $73;
     $75 = $71 >>> $73;
     $76 = $75 >>> 1;
     $77 = $76 & 1;
     $78 = $74 | $77;
     $79 = $75 >>> $77;
     $80 = (($78) + ($79))|0;
     $81 = $80 << 1;
     $82 = (27432 + ($81<<2)|0);
     $83 = ((($82)) + 8|0);
     $84 = HEAP32[$83>>2]|0;
     $85 = ((($84)) + 8|0);
     $86 = HEAP32[$85>>2]|0;
     $87 = ($86|0)==($82|0);
     if ($87) {
      $88 = 1 << $80;
      $89 = $88 ^ -1;
      $90 = $25 & $89;
      HEAP32[6848] = $90;
      $107 = $90;
     } else {
      $91 = ((($86)) + 12|0);
      HEAP32[$91>>2] = $82;
      HEAP32[$83>>2] = $86;
      $107 = $25;
     }
     $92 = $80 << 3;
     $93 = (($92) - ($23))|0;
     $94 = $23 | 3;
     $95 = ((($84)) + 4|0);
     HEAP32[$95>>2] = $94;
     $96 = (($84) + ($23)|0);
     $97 = $93 | 1;
     $98 = ((($96)) + 4|0);
     HEAP32[$98>>2] = $97;
     $99 = (($84) + ($92)|0);
     HEAP32[$99>>2] = $93;
     $100 = ($50|0)==(0);
     if (!($100)) {
      $101 = HEAP32[(27412)>>2]|0;
      $102 = $50 >>> 3;
      $103 = $102 << 1;
      $104 = (27432 + ($103<<2)|0);
      $105 = 1 << $102;
      $106 = $107 & $105;
      $108 = ($106|0)==(0);
      if ($108) {
       $109 = $107 | $105;
       HEAP32[6848] = $109;
       $$pre = ((($104)) + 8|0);
       $$0195 = $104;$$pre$phiZ2D = $$pre;
      } else {
       $110 = ((($104)) + 8|0);
       $111 = HEAP32[$110>>2]|0;
       $$0195 = $111;$$pre$phiZ2D = $110;
      }
      HEAP32[$$pre$phiZ2D>>2] = $101;
      $112 = ((($$0195)) + 12|0);
      HEAP32[$112>>2] = $101;
      $113 = ((($101)) + 8|0);
      HEAP32[$113>>2] = $$0195;
      $114 = ((($101)) + 12|0);
      HEAP32[$114>>2] = $104;
     }
     HEAP32[(27400)>>2] = $93;
     HEAP32[(27412)>>2] = $96;
     $$2 = $85;
     break;
    }
    $115 = HEAP32[(27396)>>2]|0;
    $116 = ($115|0)==(0);
    if ($116) {
     $$0193 = $23;
     label = 118;
    } else {
     $117 = (0 - ($115))|0;
     $118 = $115 & $117;
     $119 = (($118) + -1)|0;
     $120 = $119 >>> 12;
     $121 = $120 & 16;
     $122 = $119 >>> $121;
     $123 = $122 >>> 5;
     $124 = $123 & 8;
     $125 = $124 | $121;
     $126 = $122 >>> $124;
     $127 = $126 >>> 2;
     $128 = $127 & 4;
     $129 = $125 | $128;
     $130 = $126 >>> $128;
     $131 = $130 >>> 1;
     $132 = $131 & 2;
     $133 = $129 | $132;
     $134 = $130 >>> $132;
     $135 = $134 >>> 1;
     $136 = $135 & 1;
     $137 = $133 | $136;
     $138 = $134 >>> $136;
     $139 = (($137) + ($138))|0;
     $140 = (27696 + ($139<<2)|0);
     $141 = HEAP32[$140>>2]|0;
     $142 = ((($141)) + 4|0);
     $143 = HEAP32[$142>>2]|0;
     $144 = $143 & -8;
     $145 = (($144) - ($23))|0;
     $$0169$i = $141;$$0170$i = $141;$$0171$i = $145;
     while(1) {
      $146 = ((($$0169$i)) + 16|0);
      $147 = HEAP32[$146>>2]|0;
      $148 = ($147|0)==(0|0);
      if ($148) {
       $149 = ((($$0169$i)) + 20|0);
       $150 = HEAP32[$149>>2]|0;
       $151 = ($150|0)==(0|0);
       if ($151) {
        break;
       } else {
        $153 = $150;
       }
      } else {
       $153 = $147;
      }
      $152 = ((($153)) + 4|0);
      $154 = HEAP32[$152>>2]|0;
      $155 = $154 & -8;
      $156 = (($155) - ($23))|0;
      $157 = ($156>>>0)<($$0171$i>>>0);
      $spec$select$i = $157 ? $156 : $$0171$i;
      $spec$select1$i = $157 ? $153 : $$0170$i;
      $$0169$i = $153;$$0170$i = $spec$select1$i;$$0171$i = $spec$select$i;
     }
     $158 = (($$0170$i) + ($23)|0);
     $159 = ($158>>>0)>($$0170$i>>>0);
     if ($159) {
      $160 = ((($$0170$i)) + 24|0);
      $161 = HEAP32[$160>>2]|0;
      $162 = ((($$0170$i)) + 12|0);
      $163 = HEAP32[$162>>2]|0;
      $164 = ($163|0)==($$0170$i|0);
      do {
       if ($164) {
        $169 = ((($$0170$i)) + 20|0);
        $170 = HEAP32[$169>>2]|0;
        $171 = ($170|0)==(0|0);
        if ($171) {
         $172 = ((($$0170$i)) + 16|0);
         $173 = HEAP32[$172>>2]|0;
         $174 = ($173|0)==(0|0);
         if ($174) {
          $$3$i = 0;
          break;
         } else {
          $$1174$i$ph = $173;$$1176$i$ph = $172;
         }
        } else {
         $$1174$i$ph = $170;$$1176$i$ph = $169;
        }
        $$1174$i = $$1174$i$ph;$$1176$i = $$1176$i$ph;
        while(1) {
         $175 = ((($$1174$i)) + 20|0);
         $176 = HEAP32[$175>>2]|0;
         $177 = ($176|0)==(0|0);
         if ($177) {
          $178 = ((($$1174$i)) + 16|0);
          $179 = HEAP32[$178>>2]|0;
          $180 = ($179|0)==(0|0);
          if ($180) {
           break;
          } else {
           $$1174$i$be = $179;$$1176$i$be = $178;
          }
         } else {
          $$1174$i$be = $176;$$1176$i$be = $175;
         }
         $$1174$i = $$1174$i$be;$$1176$i = $$1176$i$be;
        }
        HEAP32[$$1176$i>>2] = 0;
        $$3$i = $$1174$i;
       } else {
        $165 = ((($$0170$i)) + 8|0);
        $166 = HEAP32[$165>>2]|0;
        $167 = ((($166)) + 12|0);
        HEAP32[$167>>2] = $163;
        $168 = ((($163)) + 8|0);
        HEAP32[$168>>2] = $166;
        $$3$i = $163;
       }
      } while(0);
      $181 = ($161|0)==(0|0);
      do {
       if (!($181)) {
        $182 = ((($$0170$i)) + 28|0);
        $183 = HEAP32[$182>>2]|0;
        $184 = (27696 + ($183<<2)|0);
        $185 = HEAP32[$184>>2]|0;
        $186 = ($$0170$i|0)==($185|0);
        if ($186) {
         HEAP32[$184>>2] = $$3$i;
         $cond$i = ($$3$i|0)==(0|0);
         if ($cond$i) {
          $187 = 1 << $183;
          $188 = $187 ^ -1;
          $189 = $115 & $188;
          HEAP32[(27396)>>2] = $189;
          break;
         }
        } else {
         $190 = ((($161)) + 16|0);
         $191 = HEAP32[$190>>2]|0;
         $192 = ($191|0)==($$0170$i|0);
         $193 = ((($161)) + 20|0);
         $$sink = $192 ? $190 : $193;
         HEAP32[$$sink>>2] = $$3$i;
         $194 = ($$3$i|0)==(0|0);
         if ($194) {
          break;
         }
        }
        $195 = ((($$3$i)) + 24|0);
        HEAP32[$195>>2] = $161;
        $196 = ((($$0170$i)) + 16|0);
        $197 = HEAP32[$196>>2]|0;
        $198 = ($197|0)==(0|0);
        if (!($198)) {
         $199 = ((($$3$i)) + 16|0);
         HEAP32[$199>>2] = $197;
         $200 = ((($197)) + 24|0);
         HEAP32[$200>>2] = $$3$i;
        }
        $201 = ((($$0170$i)) + 20|0);
        $202 = HEAP32[$201>>2]|0;
        $203 = ($202|0)==(0|0);
        if (!($203)) {
         $204 = ((($$3$i)) + 20|0);
         HEAP32[$204>>2] = $202;
         $205 = ((($202)) + 24|0);
         HEAP32[$205>>2] = $$3$i;
        }
       }
      } while(0);
      $206 = ($$0171$i>>>0)<(16);
      if ($206) {
       $207 = (($$0171$i) + ($23))|0;
       $208 = $207 | 3;
       $209 = ((($$0170$i)) + 4|0);
       HEAP32[$209>>2] = $208;
       $210 = (($$0170$i) + ($207)|0);
       $211 = ((($210)) + 4|0);
       $212 = HEAP32[$211>>2]|0;
       $213 = $212 | 1;
       HEAP32[$211>>2] = $213;
      } else {
       $214 = $23 | 3;
       $215 = ((($$0170$i)) + 4|0);
       HEAP32[$215>>2] = $214;
       $216 = $$0171$i | 1;
       $217 = ((($158)) + 4|0);
       HEAP32[$217>>2] = $216;
       $218 = (($158) + ($$0171$i)|0);
       HEAP32[$218>>2] = $$0171$i;
       $219 = ($50|0)==(0);
       if (!($219)) {
        $220 = HEAP32[(27412)>>2]|0;
        $221 = $50 >>> 3;
        $222 = $221 << 1;
        $223 = (27432 + ($222<<2)|0);
        $224 = 1 << $221;
        $225 = $224 & $25;
        $226 = ($225|0)==(0);
        if ($226) {
         $227 = $224 | $25;
         HEAP32[6848] = $227;
         $$pre$i = ((($223)) + 8|0);
         $$0$i = $223;$$pre$phi$iZ2D = $$pre$i;
        } else {
         $228 = ((($223)) + 8|0);
         $229 = HEAP32[$228>>2]|0;
         $$0$i = $229;$$pre$phi$iZ2D = $228;
        }
        HEAP32[$$pre$phi$iZ2D>>2] = $220;
        $230 = ((($$0$i)) + 12|0);
        HEAP32[$230>>2] = $220;
        $231 = ((($220)) + 8|0);
        HEAP32[$231>>2] = $$0$i;
        $232 = ((($220)) + 12|0);
        HEAP32[$232>>2] = $223;
       }
       HEAP32[(27400)>>2] = $$0171$i;
       HEAP32[(27412)>>2] = $158;
      }
      $233 = ((($$0170$i)) + 8|0);
      $$2 = $233;
     } else {
      $$0193 = $23;
      label = 118;
     }
    }
   } else {
    $$0193 = $23;
    label = 118;
   }
  } else {
   $234 = ($0>>>0)>(4294967231);
   if ($234) {
    $$0193 = -1;
    label = 118;
   } else {
    $235 = (($0) + 11)|0;
    $236 = $235 & -8;
    $237 = HEAP32[(27396)>>2]|0;
    $238 = ($237|0)==(0);
    if ($238) {
     $$0193 = $236;
     label = 118;
    } else {
     $239 = (0 - ($236))|0;
     $240 = $235 >>> 8;
     $241 = ($240|0)==(0);
     if ($241) {
      $$0335$i = 0;
     } else {
      $242 = ($236>>>0)>(16777215);
      if ($242) {
       $$0335$i = 31;
      } else {
       $243 = (($240) + 1048320)|0;
       $244 = $243 >>> 16;
       $245 = $244 & 8;
       $246 = $240 << $245;
       $247 = (($246) + 520192)|0;
       $248 = $247 >>> 16;
       $249 = $248 & 4;
       $250 = $249 | $245;
       $251 = $246 << $249;
       $252 = (($251) + 245760)|0;
       $253 = $252 >>> 16;
       $254 = $253 & 2;
       $255 = $250 | $254;
       $256 = (14 - ($255))|0;
       $257 = $251 << $254;
       $258 = $257 >>> 15;
       $259 = (($256) + ($258))|0;
       $260 = $259 << 1;
       $261 = (($259) + 7)|0;
       $262 = $236 >>> $261;
       $263 = $262 & 1;
       $264 = $263 | $260;
       $$0335$i = $264;
      }
     }
     $265 = (27696 + ($$0335$i<<2)|0);
     $266 = HEAP32[$265>>2]|0;
     $267 = ($266|0)==(0|0);
     L90: do {
      if ($267) {
       $$2331$i = 0;$$3$i196 = 0;$$3326$i = $239;
       label = 70;
      } else {
       $268 = ($$0335$i|0)==(31);
       $269 = $$0335$i >>> 1;
       $270 = (25 - ($269))|0;
       $271 = $268 ? 0 : $270;
       $272 = $236 << $271;
       $$0318$i = 0;$$0323$i = $239;$$0329$i = $266;$$0336$i = $272;$$0339$i = 0;
       while(1) {
        $273 = ((($$0329$i)) + 4|0);
        $274 = HEAP32[$273>>2]|0;
        $275 = $274 & -8;
        $276 = (($275) - ($236))|0;
        $277 = ($276>>>0)<($$0323$i>>>0);
        if ($277) {
         $278 = ($276|0)==(0);
         if ($278) {
          $$415$i$ph = $$0329$i;$$432714$i$ph = 0;$$533413$i$ph = $$0329$i;
          label = 74;
          break L90;
         } else {
          $$1319$i = $$0329$i;$$1324$i = $276;
         }
        } else {
         $$1319$i = $$0318$i;$$1324$i = $$0323$i;
        }
        $279 = ((($$0329$i)) + 20|0);
        $280 = HEAP32[$279>>2]|0;
        $281 = $$0336$i >>> 31;
        $282 = (((($$0329$i)) + 16|0) + ($281<<2)|0);
        $283 = HEAP32[$282>>2]|0;
        $284 = ($280|0)==(0|0);
        $285 = ($280|0)==($283|0);
        $or$cond1$i = $284 | $285;
        $$1340$i = $or$cond1$i ? $$0339$i : $280;
        $286 = ($283|0)==(0|0);
        $spec$select4$i = $$0336$i << 1;
        if ($286) {
         $$2331$i = $$1340$i;$$3$i196 = $$1319$i;$$3326$i = $$1324$i;
         label = 70;
         break;
        } else {
         $$0318$i = $$1319$i;$$0323$i = $$1324$i;$$0329$i = $283;$$0336$i = $spec$select4$i;$$0339$i = $$1340$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 70) {
      $287 = ($$2331$i|0)==(0|0);
      $288 = ($$3$i196|0)==(0|0);
      $or$cond$i = $287 & $288;
      if ($or$cond$i) {
       $289 = 2 << $$0335$i;
       $290 = (0 - ($289))|0;
       $291 = $289 | $290;
       $292 = $291 & $237;
       $293 = ($292|0)==(0);
       if ($293) {
        $$0193 = $236;
        label = 118;
        break;
       }
       $294 = (0 - ($292))|0;
       $295 = $292 & $294;
       $296 = (($295) + -1)|0;
       $297 = $296 >>> 12;
       $298 = $297 & 16;
       $299 = $296 >>> $298;
       $300 = $299 >>> 5;
       $301 = $300 & 8;
       $302 = $301 | $298;
       $303 = $299 >>> $301;
       $304 = $303 >>> 2;
       $305 = $304 & 4;
       $306 = $302 | $305;
       $307 = $303 >>> $305;
       $308 = $307 >>> 1;
       $309 = $308 & 2;
       $310 = $306 | $309;
       $311 = $307 >>> $309;
       $312 = $311 >>> 1;
       $313 = $312 & 1;
       $314 = $310 | $313;
       $315 = $311 >>> $313;
       $316 = (($314) + ($315))|0;
       $317 = (27696 + ($316<<2)|0);
       $318 = HEAP32[$317>>2]|0;
       $$3$i196210 = 0;$$4333$i = $318;
      } else {
       $$3$i196210 = $$3$i196;$$4333$i = $$2331$i;
      }
      $319 = ($$4333$i|0)==(0|0);
      if ($319) {
       $$4$lcssa$i = $$3$i196210;$$4327$lcssa$i = $$3326$i;
      } else {
       $$415$i$ph = $$3$i196210;$$432714$i$ph = $$3326$i;$$533413$i$ph = $$4333$i;
       label = 74;
      }
     }
     if ((label|0) == 74) {
      $$415$i = $$415$i$ph;$$432714$i = $$432714$i$ph;$$533413$i = $$533413$i$ph;
      while(1) {
       $320 = ((($$533413$i)) + 4|0);
       $321 = HEAP32[$320>>2]|0;
       $322 = $321 & -8;
       $323 = (($322) - ($236))|0;
       $324 = ($323>>>0)<($$432714$i>>>0);
       $spec$select$i198 = $324 ? $323 : $$432714$i;
       $spec$select2$i = $324 ? $$533413$i : $$415$i;
       $325 = ((($$533413$i)) + 16|0);
       $326 = HEAP32[$325>>2]|0;
       $327 = ($326|0)==(0|0);
       if ($327) {
        $328 = ((($$533413$i)) + 20|0);
        $329 = HEAP32[$328>>2]|0;
        $330 = $329;
       } else {
        $330 = $326;
       }
       $331 = ($330|0)==(0|0);
       if ($331) {
        $$4$lcssa$i = $spec$select2$i;$$4327$lcssa$i = $spec$select$i198;
        break;
       } else {
        $$415$i = $spec$select2$i;$$432714$i = $spec$select$i198;$$533413$i = $330;
       }
      }
     }
     $332 = ($$4$lcssa$i|0)==(0|0);
     if ($332) {
      $$0193 = $236;
      label = 118;
     } else {
      $333 = HEAP32[(27400)>>2]|0;
      $334 = (($333) - ($236))|0;
      $335 = ($$4327$lcssa$i>>>0)<($334>>>0);
      if ($335) {
       $336 = (($$4$lcssa$i) + ($236)|0);
       $337 = ($336>>>0)>($$4$lcssa$i>>>0);
       if ($337) {
        $338 = ((($$4$lcssa$i)) + 24|0);
        $339 = HEAP32[$338>>2]|0;
        $340 = ((($$4$lcssa$i)) + 12|0);
        $341 = HEAP32[$340>>2]|0;
        $342 = ($341|0)==($$4$lcssa$i|0);
        do {
         if ($342) {
          $347 = ((($$4$lcssa$i)) + 20|0);
          $348 = HEAP32[$347>>2]|0;
          $349 = ($348|0)==(0|0);
          if ($349) {
           $350 = ((($$4$lcssa$i)) + 16|0);
           $351 = HEAP32[$350>>2]|0;
           $352 = ($351|0)==(0|0);
           if ($352) {
            $$3348$i = 0;
            break;
           } else {
            $$1346$i$ph = $351;$$1350$i$ph = $350;
           }
          } else {
           $$1346$i$ph = $348;$$1350$i$ph = $347;
          }
          $$1346$i = $$1346$i$ph;$$1350$i = $$1350$i$ph;
          while(1) {
           $353 = ((($$1346$i)) + 20|0);
           $354 = HEAP32[$353>>2]|0;
           $355 = ($354|0)==(0|0);
           if ($355) {
            $356 = ((($$1346$i)) + 16|0);
            $357 = HEAP32[$356>>2]|0;
            $358 = ($357|0)==(0|0);
            if ($358) {
             break;
            } else {
             $$1346$i$be = $357;$$1350$i$be = $356;
            }
           } else {
            $$1346$i$be = $354;$$1350$i$be = $353;
           }
           $$1346$i = $$1346$i$be;$$1350$i = $$1350$i$be;
          }
          HEAP32[$$1350$i>>2] = 0;
          $$3348$i = $$1346$i;
         } else {
          $343 = ((($$4$lcssa$i)) + 8|0);
          $344 = HEAP32[$343>>2]|0;
          $345 = ((($344)) + 12|0);
          HEAP32[$345>>2] = $341;
          $346 = ((($341)) + 8|0);
          HEAP32[$346>>2] = $344;
          $$3348$i = $341;
         }
        } while(0);
        $359 = ($339|0)==(0|0);
        do {
         if ($359) {
          $442 = $237;
         } else {
          $360 = ((($$4$lcssa$i)) + 28|0);
          $361 = HEAP32[$360>>2]|0;
          $362 = (27696 + ($361<<2)|0);
          $363 = HEAP32[$362>>2]|0;
          $364 = ($$4$lcssa$i|0)==($363|0);
          if ($364) {
           HEAP32[$362>>2] = $$3348$i;
           $cond$i200 = ($$3348$i|0)==(0|0);
           if ($cond$i200) {
            $365 = 1 << $361;
            $366 = $365 ^ -1;
            $367 = $237 & $366;
            HEAP32[(27396)>>2] = $367;
            $442 = $367;
            break;
           }
          } else {
           $368 = ((($339)) + 16|0);
           $369 = HEAP32[$368>>2]|0;
           $370 = ($369|0)==($$4$lcssa$i|0);
           $371 = ((($339)) + 20|0);
           $$sink319 = $370 ? $368 : $371;
           HEAP32[$$sink319>>2] = $$3348$i;
           $372 = ($$3348$i|0)==(0|0);
           if ($372) {
            $442 = $237;
            break;
           }
          }
          $373 = ((($$3348$i)) + 24|0);
          HEAP32[$373>>2] = $339;
          $374 = ((($$4$lcssa$i)) + 16|0);
          $375 = HEAP32[$374>>2]|0;
          $376 = ($375|0)==(0|0);
          if (!($376)) {
           $377 = ((($$3348$i)) + 16|0);
           HEAP32[$377>>2] = $375;
           $378 = ((($375)) + 24|0);
           HEAP32[$378>>2] = $$3348$i;
          }
          $379 = ((($$4$lcssa$i)) + 20|0);
          $380 = HEAP32[$379>>2]|0;
          $381 = ($380|0)==(0|0);
          if ($381) {
           $442 = $237;
          } else {
           $382 = ((($$3348$i)) + 20|0);
           HEAP32[$382>>2] = $380;
           $383 = ((($380)) + 24|0);
           HEAP32[$383>>2] = $$3348$i;
           $442 = $237;
          }
         }
        } while(0);
        $384 = ($$4327$lcssa$i>>>0)<(16);
        L139: do {
         if ($384) {
          $385 = (($$4327$lcssa$i) + ($236))|0;
          $386 = $385 | 3;
          $387 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$387>>2] = $386;
          $388 = (($$4$lcssa$i) + ($385)|0);
          $389 = ((($388)) + 4|0);
          $390 = HEAP32[$389>>2]|0;
          $391 = $390 | 1;
          HEAP32[$389>>2] = $391;
         } else {
          $392 = $236 | 3;
          $393 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$393>>2] = $392;
          $394 = $$4327$lcssa$i | 1;
          $395 = ((($336)) + 4|0);
          HEAP32[$395>>2] = $394;
          $396 = (($336) + ($$4327$lcssa$i)|0);
          HEAP32[$396>>2] = $$4327$lcssa$i;
          $397 = $$4327$lcssa$i >>> 3;
          $398 = ($$4327$lcssa$i>>>0)<(256);
          if ($398) {
           $399 = $397 << 1;
           $400 = (27432 + ($399<<2)|0);
           $401 = HEAP32[6848]|0;
           $402 = 1 << $397;
           $403 = $401 & $402;
           $404 = ($403|0)==(0);
           if ($404) {
            $405 = $401 | $402;
            HEAP32[6848] = $405;
            $$pre$i201 = ((($400)) + 8|0);
            $$0344$i = $400;$$pre$phi$i202Z2D = $$pre$i201;
           } else {
            $406 = ((($400)) + 8|0);
            $407 = HEAP32[$406>>2]|0;
            $$0344$i = $407;$$pre$phi$i202Z2D = $406;
           }
           HEAP32[$$pre$phi$i202Z2D>>2] = $336;
           $408 = ((($$0344$i)) + 12|0);
           HEAP32[$408>>2] = $336;
           $409 = ((($336)) + 8|0);
           HEAP32[$409>>2] = $$0344$i;
           $410 = ((($336)) + 12|0);
           HEAP32[$410>>2] = $400;
           break;
          }
          $411 = $$4327$lcssa$i >>> 8;
          $412 = ($411|0)==(0);
          if ($412) {
           $$0338$i = 0;
          } else {
           $413 = ($$4327$lcssa$i>>>0)>(16777215);
           if ($413) {
            $$0338$i = 31;
           } else {
            $414 = (($411) + 1048320)|0;
            $415 = $414 >>> 16;
            $416 = $415 & 8;
            $417 = $411 << $416;
            $418 = (($417) + 520192)|0;
            $419 = $418 >>> 16;
            $420 = $419 & 4;
            $421 = $420 | $416;
            $422 = $417 << $420;
            $423 = (($422) + 245760)|0;
            $424 = $423 >>> 16;
            $425 = $424 & 2;
            $426 = $421 | $425;
            $427 = (14 - ($426))|0;
            $428 = $422 << $425;
            $429 = $428 >>> 15;
            $430 = (($427) + ($429))|0;
            $431 = $430 << 1;
            $432 = (($430) + 7)|0;
            $433 = $$4327$lcssa$i >>> $432;
            $434 = $433 & 1;
            $435 = $434 | $431;
            $$0338$i = $435;
           }
          }
          $436 = (27696 + ($$0338$i<<2)|0);
          $437 = ((($336)) + 28|0);
          HEAP32[$437>>2] = $$0338$i;
          $438 = ((($336)) + 16|0);
          $439 = ((($438)) + 4|0);
          HEAP32[$439>>2] = 0;
          HEAP32[$438>>2] = 0;
          $440 = 1 << $$0338$i;
          $441 = $442 & $440;
          $443 = ($441|0)==(0);
          if ($443) {
           $444 = $442 | $440;
           HEAP32[(27396)>>2] = $444;
           HEAP32[$436>>2] = $336;
           $445 = ((($336)) + 24|0);
           HEAP32[$445>>2] = $436;
           $446 = ((($336)) + 12|0);
           HEAP32[$446>>2] = $336;
           $447 = ((($336)) + 8|0);
           HEAP32[$447>>2] = $336;
           break;
          }
          $448 = HEAP32[$436>>2]|0;
          $449 = ((($448)) + 4|0);
          $450 = HEAP32[$449>>2]|0;
          $451 = $450 & -8;
          $452 = ($451|0)==($$4327$lcssa$i|0);
          L156: do {
           if ($452) {
            $$0321$lcssa$i = $448;
           } else {
            $453 = ($$0338$i|0)==(31);
            $454 = $$0338$i >>> 1;
            $455 = (25 - ($454))|0;
            $456 = $453 ? 0 : $455;
            $457 = $$4327$lcssa$i << $456;
            $$032012$i = $457;$$032111$i = $448;
            while(1) {
             $464 = $$032012$i >>> 31;
             $465 = (((($$032111$i)) + 16|0) + ($464<<2)|0);
             $460 = HEAP32[$465>>2]|0;
             $466 = ($460|0)==(0|0);
             if ($466) {
              break;
             }
             $458 = $$032012$i << 1;
             $459 = ((($460)) + 4|0);
             $461 = HEAP32[$459>>2]|0;
             $462 = $461 & -8;
             $463 = ($462|0)==($$4327$lcssa$i|0);
             if ($463) {
              $$0321$lcssa$i = $460;
              break L156;
             } else {
              $$032012$i = $458;$$032111$i = $460;
             }
            }
            HEAP32[$465>>2] = $336;
            $467 = ((($336)) + 24|0);
            HEAP32[$467>>2] = $$032111$i;
            $468 = ((($336)) + 12|0);
            HEAP32[$468>>2] = $336;
            $469 = ((($336)) + 8|0);
            HEAP32[$469>>2] = $336;
            break L139;
           }
          } while(0);
          $470 = ((($$0321$lcssa$i)) + 8|0);
          $471 = HEAP32[$470>>2]|0;
          $472 = ((($471)) + 12|0);
          HEAP32[$472>>2] = $336;
          HEAP32[$470>>2] = $336;
          $473 = ((($336)) + 8|0);
          HEAP32[$473>>2] = $471;
          $474 = ((($336)) + 12|0);
          HEAP32[$474>>2] = $$0321$lcssa$i;
          $475 = ((($336)) + 24|0);
          HEAP32[$475>>2] = 0;
         }
        } while(0);
        $476 = ((($$4$lcssa$i)) + 8|0);
        $$2 = $476;
       } else {
        $$0193 = $236;
        label = 118;
       }
      } else {
       $$0193 = $236;
       label = 118;
      }
     }
    }
   }
  }
 } while(0);
 L164: do {
  if ((label|0) == 118) {
   $477 = HEAP32[(27400)>>2]|0;
   $478 = ($477>>>0)<($$0193>>>0);
   if (!($478)) {
    $479 = (($477) - ($$0193))|0;
    $480 = HEAP32[(27412)>>2]|0;
    $481 = ($479>>>0)>(15);
    if ($481) {
     $482 = (($480) + ($$0193)|0);
     HEAP32[(27412)>>2] = $482;
     HEAP32[(27400)>>2] = $479;
     $483 = $479 | 1;
     $484 = ((($482)) + 4|0);
     HEAP32[$484>>2] = $483;
     $485 = (($480) + ($477)|0);
     HEAP32[$485>>2] = $479;
     $486 = $$0193 | 3;
     $487 = ((($480)) + 4|0);
     HEAP32[$487>>2] = $486;
    } else {
     HEAP32[(27400)>>2] = 0;
     HEAP32[(27412)>>2] = 0;
     $488 = $477 | 3;
     $489 = ((($480)) + 4|0);
     HEAP32[$489>>2] = $488;
     $490 = (($480) + ($477)|0);
     $491 = ((($490)) + 4|0);
     $492 = HEAP32[$491>>2]|0;
     $493 = $492 | 1;
     HEAP32[$491>>2] = $493;
    }
    $494 = ((($480)) + 8|0);
    $$2 = $494;
    break;
   }
   $495 = HEAP32[(27404)>>2]|0;
   $496 = ($495>>>0)>($$0193>>>0);
   if ($496) {
    $497 = (($495) - ($$0193))|0;
    HEAP32[(27404)>>2] = $497;
    $498 = HEAP32[(27416)>>2]|0;
    $499 = (($498) + ($$0193)|0);
    HEAP32[(27416)>>2] = $499;
    $500 = $497 | 1;
    $501 = ((($499)) + 4|0);
    HEAP32[$501>>2] = $500;
    $502 = $$0193 | 3;
    $503 = ((($498)) + 4|0);
    HEAP32[$503>>2] = $502;
    $504 = ((($498)) + 8|0);
    $$2 = $504;
    break;
   }
   $505 = HEAP32[6835]|0;
   $506 = ($505|0)==(0);
   if ($506) {
    (___pthread_mutex_lock(27364)|0);
    $507 = HEAP32[6835]|0;
    $508 = ($507|0)==(0);
    if ($508) {
     HEAP32[(27348)>>2] = 4096;
     HEAP32[(27344)>>2] = 4096;
     HEAP32[(27352)>>2] = -1;
     HEAP32[(27356)>>2] = -1;
     HEAP32[(27360)>>2] = 2;
     HEAP32[(27836)>>2] = 2;
     $509 = (_pthread_mutexattr_init($1)|0);
     $510 = ($509|0)==(0);
     if ($510) {
      $511 = (_pthread_mutex_init((27840),$1)|0);
      $512 = ($511|0)==(0);
      if ($512) {
      }
     }
     $513 = $2;
     $514 = $513 & -16;
     $515 = $514 ^ 1431655768;
     Atomics_store(HEAP32,6835,$515)|0;
    }
    (___pthread_mutex_unlock(27364)|0);
   }
   $516 = (($$0193) + 48)|0;
   $517 = HEAP32[(27348)>>2]|0;
   $518 = (($$0193) + 47)|0;
   $519 = (($517) + ($518))|0;
   $520 = (0 - ($517))|0;
   $521 = $519 & $520;
   $522 = ($521>>>0)>($$0193>>>0);
   if ($522) {
    $523 = HEAP32[(27832)>>2]|0;
    $524 = ($523|0)==(0);
    if (!($524)) {
     $525 = HEAP32[(27824)>>2]|0;
     $526 = (($525) + ($521))|0;
     $527 = ($526>>>0)<=($525>>>0);
     $528 = ($526>>>0)>($523>>>0);
     $or$cond1$i203 = $527 | $528;
     if ($or$cond1$i203) {
      $$2 = 0;
      break;
     }
    }
    $529 = HEAP32[(27836)>>2]|0;
    $530 = $529 & 4;
    $531 = ($530|0)==(0);
    if ($531) {
     $532 = HEAP32[(27416)>>2]|0;
     $533 = ($532|0)==(0|0);
     L192: do {
      if ($533) {
       label = 141;
      } else {
       $$0$i$i = (27868);
       while(1) {
        $534 = HEAP32[$$0$i$i>>2]|0;
        $535 = ($534>>>0)>($532>>>0);
        if (!($535)) {
         $536 = ((($$0$i$i)) + 4|0);
         $537 = HEAP32[$536>>2]|0;
         $538 = (($534) + ($537)|0);
         $539 = ($538>>>0)>($532>>>0);
         if ($539) {
          break;
         }
        }
        $540 = ((($$0$i$i)) + 8|0);
        $541 = HEAP32[$540>>2]|0;
        $542 = ($541|0)==(0|0);
        if ($542) {
         label = 141;
         break L192;
        } else {
         $$0$i$i = $541;
        }
       }
       (___pthread_mutex_lock(27364)|0);
       $565 = HEAP32[(27404)>>2]|0;
       $566 = HEAP32[(27348)>>2]|0;
       $567 = (($518) - ($565))|0;
       $568 = (($567) + ($566))|0;
       $569 = (0 - ($566))|0;
       $570 = $568 & $569;
       $571 = ($570>>>0)<(2147483647);
       if ($571) {
        $572 = ((($$0$i$i)) + 4|0);
        $573 = (_sbrk(($570|0))|0);
        $574 = HEAP32[$$0$i$i>>2]|0;
        $575 = HEAP32[$572>>2]|0;
        $576 = (($574) + ($575)|0);
        $577 = ($573|0)==($576|0);
        if ($577) {
         $578 = ($573|0)==((-1)|0);
         if ($578) {
          $$2234243136$i = $570;
          label = 155;
         } else {
          $$3229$i = $573;$$3235$i = $570;
         }
        } else {
         $$2247$ph$i = $573;$$2253$ph$i = $570;
         label = 149;
        }
       } else {
        $$2234243136$i = 0;
        label = 155;
       }
      }
     } while(0);
     do {
      if ((label|0) == 141) {
       (___pthread_mutex_lock(27364)|0);
       $543 = (_sbrk(0)|0);
       $544 = ($543|0)==((-1)|0);
       if ($544) {
        $$2234243136$i = 0;
        label = 155;
       } else {
        $545 = $543;
        $546 = HEAP32[(27344)>>2]|0;
        $547 = (($546) + -1)|0;
        $548 = $547 & $545;
        $549 = ($548|0)==(0);
        $550 = (($547) + ($545))|0;
        $551 = (0 - ($546))|0;
        $552 = $550 & $551;
        $553 = (($552) - ($545))|0;
        $554 = $549 ? 0 : $553;
        $spec$select42$i = (($554) + ($521))|0;
        $555 = HEAP32[(27824)>>2]|0;
        $556 = (($spec$select42$i) + ($555))|0;
        $557 = ($spec$select42$i>>>0)>($$0193>>>0);
        $558 = ($spec$select42$i>>>0)<(2147483647);
        $or$cond$i205 = $557 & $558;
        if ($or$cond$i205) {
         $559 = HEAP32[(27832)>>2]|0;
         $560 = ($559|0)==(0);
         if (!($560)) {
          $561 = ($556>>>0)<=($555>>>0);
          $562 = ($556>>>0)>($559>>>0);
          $or$cond2$i = $561 | $562;
          if ($or$cond2$i) {
           $$2234243136$i = 0;
           label = 155;
           break;
          }
         }
         $563 = (_sbrk(($spec$select42$i|0))|0);
         $564 = ($563|0)==($543|0);
         if ($564) {
          $$3229$i = $543;$$3235$i = $spec$select42$i;
         } else {
          $$2247$ph$i = $563;$$2253$ph$i = $spec$select42$i;
          label = 149;
         }
        } else {
         $$2234243136$i = 0;
         label = 155;
        }
       }
      }
     } while(0);
     do {
      if ((label|0) == 149) {
       $579 = (0 - ($$2253$ph$i))|0;
       $580 = ($$2247$ph$i|0)!=((-1)|0);
       $581 = ($$2253$ph$i>>>0)<(2147483647);
       $or$cond7$i = $581 & $580;
       $582 = ($516>>>0)>($$2253$ph$i>>>0);
       $or$cond6$i = $582 & $or$cond7$i;
       if (!($or$cond6$i)) {
        $592 = ($$2247$ph$i|0)==((-1)|0);
        if ($592) {
         $$2234243136$i = 0;
         label = 155;
         break;
        } else {
         $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
         break;
        }
       }
       $583 = HEAP32[(27348)>>2]|0;
       $584 = (($518) - ($$2253$ph$i))|0;
       $585 = (($584) + ($583))|0;
       $586 = (0 - ($583))|0;
       $587 = $585 & $586;
       $588 = ($587>>>0)<(2147483647);
       if ($588) {
        $589 = (_sbrk(($587|0))|0);
        $590 = ($589|0)==((-1)|0);
        if ($590) {
         (_sbrk(($579|0))|0);
         $$2234243136$i = 0;
         label = 155;
         break;
        } else {
         $591 = (($587) + ($$2253$ph$i))|0;
         $$3229$i = $$2247$ph$i;$$3235$i = $591;
         break;
        }
       } else {
        $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
       }
      }
     } while(0);
     if ((label|0) == 155) {
      $593 = HEAP32[(27836)>>2]|0;
      $594 = $593 | 4;
      HEAP32[(27836)>>2] = $594;
      $$3229$i = (-1);$$3235$i = $$2234243136$i;
     }
     (___pthread_mutex_unlock(27364)|0);
     $$4230$i = $$3229$i;$$4236$i = $$3235$i;
    } else {
     $$4230$i = (-1);$$4236$i = 0;
    }
    $595 = ($$4230$i|0)==((-1)|0);
    $596 = ($521>>>0)<(2147483647);
    $or$cond9$i = $596 & $595;
    if ($or$cond9$i) {
     (___pthread_mutex_lock(27364)|0);
     $597 = (_sbrk(($521|0))|0);
     $598 = (_sbrk(0)|0);
     (___pthread_mutex_unlock(27364)|0);
     $599 = ($597|0)!=((-1)|0);
     $600 = ($598|0)!=((-1)|0);
     $or$cond5$i = $599 & $600;
     $601 = ($597>>>0)<($598>>>0);
     $or$cond8$i = $601 & $or$cond5$i;
     $602 = $598;
     $603 = $597;
     $604 = (($602) - ($603))|0;
     $605 = (($$0193) + 40)|0;
     $606 = ($604>>>0)>($605>>>0);
     $spec$select9$i = $606 ? $604 : $$4236$i;
     $spec$select10$i = $606 ? $597 : (-1);
     if ($or$cond8$i) {
      $$7$i = $spec$select10$i;$$7239$i = $spec$select9$i;
      label = 159;
     }
    } else {
     $$7$i = $$4230$i;$$7239$i = $$4236$i;
     label = 159;
    }
    if ((label|0) == 159) {
     $607 = ($$7$i|0)==((-1)|0);
     if (!($607)) {
      $608 = HEAP32[(27824)>>2]|0;
      $609 = (($608) + ($$7239$i))|0;
      HEAP32[(27824)>>2] = $609;
      $610 = HEAP32[(27828)>>2]|0;
      $611 = ($609>>>0)>($610>>>0);
      if ($611) {
       HEAP32[(27828)>>2] = $609;
      }
      $612 = HEAP32[(27416)>>2]|0;
      $613 = ($612|0)==(0|0);
      L230: do {
       if ($613) {
        $614 = HEAP32[(27408)>>2]|0;
        $615 = ($614|0)==(0|0);
        $616 = ($$7$i>>>0)<($614>>>0);
        $or$cond11$i = $615 | $616;
        if ($or$cond11$i) {
         HEAP32[(27408)>>2] = $$7$i;
        }
        HEAP32[(27868)>>2] = $$7$i;
        HEAP32[(27872)>>2] = $$7239$i;
        HEAP32[(27880)>>2] = 0;
        $617 = HEAP32[6835]|0;
        HEAP32[(27428)>>2] = $617;
        HEAP32[(27424)>>2] = -1;
        HEAP32[(27444)>>2] = (27432);
        HEAP32[(27440)>>2] = (27432);
        HEAP32[(27452)>>2] = (27440);
        HEAP32[(27448)>>2] = (27440);
        HEAP32[(27460)>>2] = (27448);
        HEAP32[(27456)>>2] = (27448);
        HEAP32[(27468)>>2] = (27456);
        HEAP32[(27464)>>2] = (27456);
        HEAP32[(27476)>>2] = (27464);
        HEAP32[(27472)>>2] = (27464);
        HEAP32[(27484)>>2] = (27472);
        HEAP32[(27480)>>2] = (27472);
        HEAP32[(27492)>>2] = (27480);
        HEAP32[(27488)>>2] = (27480);
        HEAP32[(27500)>>2] = (27488);
        HEAP32[(27496)>>2] = (27488);
        HEAP32[(27508)>>2] = (27496);
        HEAP32[(27504)>>2] = (27496);
        HEAP32[(27516)>>2] = (27504);
        HEAP32[(27512)>>2] = (27504);
        HEAP32[(27524)>>2] = (27512);
        HEAP32[(27520)>>2] = (27512);
        HEAP32[(27532)>>2] = (27520);
        HEAP32[(27528)>>2] = (27520);
        HEAP32[(27540)>>2] = (27528);
        HEAP32[(27536)>>2] = (27528);
        HEAP32[(27548)>>2] = (27536);
        HEAP32[(27544)>>2] = (27536);
        HEAP32[(27556)>>2] = (27544);
        HEAP32[(27552)>>2] = (27544);
        HEAP32[(27564)>>2] = (27552);
        HEAP32[(27560)>>2] = (27552);
        HEAP32[(27572)>>2] = (27560);
        HEAP32[(27568)>>2] = (27560);
        HEAP32[(27580)>>2] = (27568);
        HEAP32[(27576)>>2] = (27568);
        HEAP32[(27588)>>2] = (27576);
        HEAP32[(27584)>>2] = (27576);
        HEAP32[(27596)>>2] = (27584);
        HEAP32[(27592)>>2] = (27584);
        HEAP32[(27604)>>2] = (27592);
        HEAP32[(27600)>>2] = (27592);
        HEAP32[(27612)>>2] = (27600);
        HEAP32[(27608)>>2] = (27600);
        HEAP32[(27620)>>2] = (27608);
        HEAP32[(27616)>>2] = (27608);
        HEAP32[(27628)>>2] = (27616);
        HEAP32[(27624)>>2] = (27616);
        HEAP32[(27636)>>2] = (27624);
        HEAP32[(27632)>>2] = (27624);
        HEAP32[(27644)>>2] = (27632);
        HEAP32[(27640)>>2] = (27632);
        HEAP32[(27652)>>2] = (27640);
        HEAP32[(27648)>>2] = (27640);
        HEAP32[(27660)>>2] = (27648);
        HEAP32[(27656)>>2] = (27648);
        HEAP32[(27668)>>2] = (27656);
        HEAP32[(27664)>>2] = (27656);
        HEAP32[(27676)>>2] = (27664);
        HEAP32[(27672)>>2] = (27664);
        HEAP32[(27684)>>2] = (27672);
        HEAP32[(27680)>>2] = (27672);
        HEAP32[(27692)>>2] = (27680);
        HEAP32[(27688)>>2] = (27680);
        $618 = (($$7239$i) + -40)|0;
        $619 = ((($$7$i)) + 8|0);
        $620 = $619;
        $621 = $620 & 7;
        $622 = ($621|0)==(0);
        $623 = (0 - ($620))|0;
        $624 = $623 & 7;
        $625 = $622 ? 0 : $624;
        $626 = (($$7$i) + ($625)|0);
        $627 = (($618) - ($625))|0;
        HEAP32[(27416)>>2] = $626;
        HEAP32[(27404)>>2] = $627;
        $628 = $627 | 1;
        $629 = ((($626)) + 4|0);
        HEAP32[$629>>2] = $628;
        $630 = (($$7$i) + ($618)|0);
        $631 = ((($630)) + 4|0);
        HEAP32[$631>>2] = 40;
        $632 = HEAP32[(27356)>>2]|0;
        HEAP32[(27420)>>2] = $632;
       } else {
        $$024364$i = (27868);
        while(1) {
         $633 = HEAP32[$$024364$i>>2]|0;
         $634 = ((($$024364$i)) + 4|0);
         $635 = HEAP32[$634>>2]|0;
         $636 = (($633) + ($635)|0);
         $637 = ($$7$i|0)==($636|0);
         if ($637) {
          label = 169;
          break;
         }
         $638 = ((($$024364$i)) + 8|0);
         $639 = HEAP32[$638>>2]|0;
         $640 = ($639|0)==(0|0);
         if ($640) {
          break;
         } else {
          $$024364$i = $639;
         }
        }
        if ((label|0) == 169) {
         $641 = ((($$024364$i)) + 4|0);
         $642 = ((($$024364$i)) + 12|0);
         $643 = HEAP32[$642>>2]|0;
         $644 = $643 & 8;
         $645 = ($644|0)==(0);
         if ($645) {
          $646 = ($633>>>0)<=($612>>>0);
          $647 = ($$7$i>>>0)>($612>>>0);
          $or$cond43$i = $647 & $646;
          if ($or$cond43$i) {
           $648 = (($635) + ($$7239$i))|0;
           HEAP32[$641>>2] = $648;
           $649 = HEAP32[(27404)>>2]|0;
           $650 = (($649) + ($$7239$i))|0;
           $651 = ((($612)) + 8|0);
           $652 = $651;
           $653 = $652 & 7;
           $654 = ($653|0)==(0);
           $655 = (0 - ($652))|0;
           $656 = $655 & 7;
           $657 = $654 ? 0 : $656;
           $658 = (($612) + ($657)|0);
           $659 = (($650) - ($657))|0;
           HEAP32[(27416)>>2] = $658;
           HEAP32[(27404)>>2] = $659;
           $660 = $659 | 1;
           $661 = ((($658)) + 4|0);
           HEAP32[$661>>2] = $660;
           $662 = (($612) + ($650)|0);
           $663 = ((($662)) + 4|0);
           HEAP32[$663>>2] = 40;
           $664 = HEAP32[(27356)>>2]|0;
           HEAP32[(27420)>>2] = $664;
           break;
          }
         }
        }
        $665 = HEAP32[(27408)>>2]|0;
        $666 = ($$7$i>>>0)<($665>>>0);
        if ($666) {
         HEAP32[(27408)>>2] = $$7$i;
        }
        $667 = (($$7$i) + ($$7239$i)|0);
        $$124463$i = (27868);
        while(1) {
         $668 = HEAP32[$$124463$i>>2]|0;
         $669 = ($668|0)==($667|0);
         if ($669) {
          label = 177;
          break;
         }
         $670 = ((($$124463$i)) + 8|0);
         $671 = HEAP32[$670>>2]|0;
         $672 = ($671|0)==(0|0);
         if ($672) {
          break;
         } else {
          $$124463$i = $671;
         }
        }
        if ((label|0) == 177) {
         $673 = ((($$124463$i)) + 12|0);
         $674 = HEAP32[$673>>2]|0;
         $675 = $674 & 8;
         $676 = ($675|0)==(0);
         if ($676) {
          HEAP32[$$124463$i>>2] = $$7$i;
          $677 = ((($$124463$i)) + 4|0);
          $678 = HEAP32[$677>>2]|0;
          $679 = (($678) + ($$7239$i))|0;
          HEAP32[$677>>2] = $679;
          $680 = ((($$7$i)) + 8|0);
          $681 = $680;
          $682 = $681 & 7;
          $683 = ($682|0)==(0);
          $684 = (0 - ($681))|0;
          $685 = $684 & 7;
          $686 = $683 ? 0 : $685;
          $687 = (($$7$i) + ($686)|0);
          $688 = ((($667)) + 8|0);
          $689 = $688;
          $690 = $689 & 7;
          $691 = ($690|0)==(0);
          $692 = (0 - ($689))|0;
          $693 = $692 & 7;
          $694 = $691 ? 0 : $693;
          $695 = (($667) + ($694)|0);
          $696 = $695;
          $697 = $687;
          $698 = (($696) - ($697))|0;
          $699 = (($687) + ($$0193)|0);
          $700 = (($698) - ($$0193))|0;
          $701 = $$0193 | 3;
          $702 = ((($687)) + 4|0);
          HEAP32[$702>>2] = $701;
          $703 = ($612|0)==($695|0);
          L253: do {
           if ($703) {
            $704 = HEAP32[(27404)>>2]|0;
            $705 = (($704) + ($700))|0;
            HEAP32[(27404)>>2] = $705;
            HEAP32[(27416)>>2] = $699;
            $706 = $705 | 1;
            $707 = ((($699)) + 4|0);
            HEAP32[$707>>2] = $706;
           } else {
            $708 = HEAP32[(27412)>>2]|0;
            $709 = ($708|0)==($695|0);
            if ($709) {
             $710 = HEAP32[(27400)>>2]|0;
             $711 = (($710) + ($700))|0;
             HEAP32[(27400)>>2] = $711;
             HEAP32[(27412)>>2] = $699;
             $712 = $711 | 1;
             $713 = ((($699)) + 4|0);
             HEAP32[$713>>2] = $712;
             $714 = (($699) + ($711)|0);
             HEAP32[$714>>2] = $711;
             break;
            }
            $715 = ((($695)) + 4|0);
            $716 = HEAP32[$715>>2]|0;
            $717 = $716 & 3;
            $718 = ($717|0)==(1);
            if ($718) {
             $719 = $716 & -8;
             $720 = $716 >>> 3;
             $721 = ($716>>>0)<(256);
             L261: do {
              if ($721) {
               $722 = ((($695)) + 8|0);
               $723 = HEAP32[$722>>2]|0;
               $724 = ((($695)) + 12|0);
               $725 = HEAP32[$724>>2]|0;
               $726 = ($725|0)==($723|0);
               if ($726) {
                $727 = 1 << $720;
                $728 = $727 ^ -1;
                $729 = HEAP32[6848]|0;
                $730 = $729 & $728;
                HEAP32[6848] = $730;
                break;
               } else {
                $731 = ((($723)) + 12|0);
                HEAP32[$731>>2] = $725;
                $732 = ((($725)) + 8|0);
                HEAP32[$732>>2] = $723;
                break;
               }
              } else {
               $733 = ((($695)) + 24|0);
               $734 = HEAP32[$733>>2]|0;
               $735 = ((($695)) + 12|0);
               $736 = HEAP32[$735>>2]|0;
               $737 = ($736|0)==($695|0);
               do {
                if ($737) {
                 $742 = ((($695)) + 16|0);
                 $743 = ((($742)) + 4|0);
                 $744 = HEAP32[$743>>2]|0;
                 $745 = ($744|0)==(0|0);
                 if ($745) {
                  $746 = HEAP32[$742>>2]|0;
                  $747 = ($746|0)==(0|0);
                  if ($747) {
                   $$3$i$i = 0;
                   break;
                  } else {
                   $$1263$i$i$ph = $746;$$1265$i$i$ph = $742;
                  }
                 } else {
                  $$1263$i$i$ph = $744;$$1265$i$i$ph = $743;
                 }
                 $$1263$i$i = $$1263$i$i$ph;$$1265$i$i = $$1265$i$i$ph;
                 while(1) {
                  $748 = ((($$1263$i$i)) + 20|0);
                  $749 = HEAP32[$748>>2]|0;
                  $750 = ($749|0)==(0|0);
                  if ($750) {
                   $751 = ((($$1263$i$i)) + 16|0);
                   $752 = HEAP32[$751>>2]|0;
                   $753 = ($752|0)==(0|0);
                   if ($753) {
                    break;
                   } else {
                    $$1263$i$i$be = $752;$$1265$i$i$be = $751;
                   }
                  } else {
                   $$1263$i$i$be = $749;$$1265$i$i$be = $748;
                  }
                  $$1263$i$i = $$1263$i$i$be;$$1265$i$i = $$1265$i$i$be;
                 }
                 HEAP32[$$1265$i$i>>2] = 0;
                 $$3$i$i = $$1263$i$i;
                } else {
                 $738 = ((($695)) + 8|0);
                 $739 = HEAP32[$738>>2]|0;
                 $740 = ((($739)) + 12|0);
                 HEAP32[$740>>2] = $736;
                 $741 = ((($736)) + 8|0);
                 HEAP32[$741>>2] = $739;
                 $$3$i$i = $736;
                }
               } while(0);
               $754 = ($734|0)==(0|0);
               if ($754) {
                break;
               }
               $755 = ((($695)) + 28|0);
               $756 = HEAP32[$755>>2]|0;
               $757 = (27696 + ($756<<2)|0);
               $758 = HEAP32[$757>>2]|0;
               $759 = ($758|0)==($695|0);
               do {
                if ($759) {
                 HEAP32[$757>>2] = $$3$i$i;
                 $cond$i$i = ($$3$i$i|0)==(0|0);
                 if (!($cond$i$i)) {
                  break;
                 }
                 $760 = 1 << $756;
                 $761 = $760 ^ -1;
                 $762 = HEAP32[(27396)>>2]|0;
                 $763 = $762 & $761;
                 HEAP32[(27396)>>2] = $763;
                 break L261;
                } else {
                 $764 = ((($734)) + 16|0);
                 $765 = HEAP32[$764>>2]|0;
                 $766 = ($765|0)==($695|0);
                 $767 = ((($734)) + 20|0);
                 $$sink320 = $766 ? $764 : $767;
                 HEAP32[$$sink320>>2] = $$3$i$i;
                 $768 = ($$3$i$i|0)==(0|0);
                 if ($768) {
                  break L261;
                 }
                }
               } while(0);
               $769 = ((($$3$i$i)) + 24|0);
               HEAP32[$769>>2] = $734;
               $770 = ((($695)) + 16|0);
               $771 = HEAP32[$770>>2]|0;
               $772 = ($771|0)==(0|0);
               if (!($772)) {
                $773 = ((($$3$i$i)) + 16|0);
                HEAP32[$773>>2] = $771;
                $774 = ((($771)) + 24|0);
                HEAP32[$774>>2] = $$3$i$i;
               }
               $775 = ((($770)) + 4|0);
               $776 = HEAP32[$775>>2]|0;
               $777 = ($776|0)==(0|0);
               if ($777) {
                break;
               }
               $778 = ((($$3$i$i)) + 20|0);
               HEAP32[$778>>2] = $776;
               $779 = ((($776)) + 24|0);
               HEAP32[$779>>2] = $$3$i$i;
              }
             } while(0);
             $780 = (($695) + ($719)|0);
             $781 = (($719) + ($700))|0;
             $$0$i16$i = $780;$$0259$i$i = $781;
            } else {
             $$0$i16$i = $695;$$0259$i$i = $700;
            }
            $782 = ((($$0$i16$i)) + 4|0);
            $783 = HEAP32[$782>>2]|0;
            $784 = $783 & -2;
            HEAP32[$782>>2] = $784;
            $785 = $$0259$i$i | 1;
            $786 = ((($699)) + 4|0);
            HEAP32[$786>>2] = $785;
            $787 = (($699) + ($$0259$i$i)|0);
            HEAP32[$787>>2] = $$0259$i$i;
            $788 = $$0259$i$i >>> 3;
            $789 = ($$0259$i$i>>>0)<(256);
            if ($789) {
             $790 = $788 << 1;
             $791 = (27432 + ($790<<2)|0);
             $792 = HEAP32[6848]|0;
             $793 = 1 << $788;
             $794 = $792 & $793;
             $795 = ($794|0)==(0);
             if ($795) {
              $796 = $792 | $793;
              HEAP32[6848] = $796;
              $$pre$i$i = ((($791)) + 8|0);
              $$0267$i$i = $791;$$pre$phi$i$iZ2D = $$pre$i$i;
             } else {
              $797 = ((($791)) + 8|0);
              $798 = HEAP32[$797>>2]|0;
              $$0267$i$i = $798;$$pre$phi$i$iZ2D = $797;
             }
             HEAP32[$$pre$phi$i$iZ2D>>2] = $699;
             $799 = ((($$0267$i$i)) + 12|0);
             HEAP32[$799>>2] = $699;
             $800 = ((($699)) + 8|0);
             HEAP32[$800>>2] = $$0267$i$i;
             $801 = ((($699)) + 12|0);
             HEAP32[$801>>2] = $791;
             break;
            }
            $802 = $$0259$i$i >>> 8;
            $803 = ($802|0)==(0);
            do {
             if ($803) {
              $$0268$i$i = 0;
             } else {
              $804 = ($$0259$i$i>>>0)>(16777215);
              if ($804) {
               $$0268$i$i = 31;
               break;
              }
              $805 = (($802) + 1048320)|0;
              $806 = $805 >>> 16;
              $807 = $806 & 8;
              $808 = $802 << $807;
              $809 = (($808) + 520192)|0;
              $810 = $809 >>> 16;
              $811 = $810 & 4;
              $812 = $811 | $807;
              $813 = $808 << $811;
              $814 = (($813) + 245760)|0;
              $815 = $814 >>> 16;
              $816 = $815 & 2;
              $817 = $812 | $816;
              $818 = (14 - ($817))|0;
              $819 = $813 << $816;
              $820 = $819 >>> 15;
              $821 = (($818) + ($820))|0;
              $822 = $821 << 1;
              $823 = (($821) + 7)|0;
              $824 = $$0259$i$i >>> $823;
              $825 = $824 & 1;
              $826 = $825 | $822;
              $$0268$i$i = $826;
             }
            } while(0);
            $827 = (27696 + ($$0268$i$i<<2)|0);
            $828 = ((($699)) + 28|0);
            HEAP32[$828>>2] = $$0268$i$i;
            $829 = ((($699)) + 16|0);
            $830 = ((($829)) + 4|0);
            HEAP32[$830>>2] = 0;
            HEAP32[$829>>2] = 0;
            $831 = HEAP32[(27396)>>2]|0;
            $832 = 1 << $$0268$i$i;
            $833 = $831 & $832;
            $834 = ($833|0)==(0);
            if ($834) {
             $835 = $831 | $832;
             HEAP32[(27396)>>2] = $835;
             HEAP32[$827>>2] = $699;
             $836 = ((($699)) + 24|0);
             HEAP32[$836>>2] = $827;
             $837 = ((($699)) + 12|0);
             HEAP32[$837>>2] = $699;
             $838 = ((($699)) + 8|0);
             HEAP32[$838>>2] = $699;
             break;
            }
            $839 = HEAP32[$827>>2]|0;
            $840 = ((($839)) + 4|0);
            $841 = HEAP32[$840>>2]|0;
            $842 = $841 & -8;
            $843 = ($842|0)==($$0259$i$i|0);
            L306: do {
             if ($843) {
              $$0261$lcssa$i$i = $839;
             } else {
              $844 = ($$0268$i$i|0)==(31);
              $845 = $$0268$i$i >>> 1;
              $846 = (25 - ($845))|0;
              $847 = $844 ? 0 : $846;
              $848 = $$0259$i$i << $847;
              $$02604$i$i = $848;$$02613$i$i = $839;
              while(1) {
               $855 = $$02604$i$i >>> 31;
               $856 = (((($$02613$i$i)) + 16|0) + ($855<<2)|0);
               $851 = HEAP32[$856>>2]|0;
               $857 = ($851|0)==(0|0);
               if ($857) {
                break;
               }
               $849 = $$02604$i$i << 1;
               $850 = ((($851)) + 4|0);
               $852 = HEAP32[$850>>2]|0;
               $853 = $852 & -8;
               $854 = ($853|0)==($$0259$i$i|0);
               if ($854) {
                $$0261$lcssa$i$i = $851;
                break L306;
               } else {
                $$02604$i$i = $849;$$02613$i$i = $851;
               }
              }
              HEAP32[$856>>2] = $699;
              $858 = ((($699)) + 24|0);
              HEAP32[$858>>2] = $$02613$i$i;
              $859 = ((($699)) + 12|0);
              HEAP32[$859>>2] = $699;
              $860 = ((($699)) + 8|0);
              HEAP32[$860>>2] = $699;
              break L253;
             }
            } while(0);
            $861 = ((($$0261$lcssa$i$i)) + 8|0);
            $862 = HEAP32[$861>>2]|0;
            $863 = ((($862)) + 12|0);
            HEAP32[$863>>2] = $699;
            HEAP32[$861>>2] = $699;
            $864 = ((($699)) + 8|0);
            HEAP32[$864>>2] = $862;
            $865 = ((($699)) + 12|0);
            HEAP32[$865>>2] = $$0261$lcssa$i$i;
            $866 = ((($699)) + 24|0);
            HEAP32[$866>>2] = 0;
           }
          } while(0);
          $995 = ((($687)) + 8|0);
          $$2 = $995;
          break L164;
         }
        }
        $$0$i$i$i = (27868);
        while(1) {
         $867 = HEAP32[$$0$i$i$i>>2]|0;
         $868 = ($867>>>0)>($612>>>0);
         if (!($868)) {
          $869 = ((($$0$i$i$i)) + 4|0);
          $870 = HEAP32[$869>>2]|0;
          $871 = (($867) + ($870)|0);
          $872 = ($871>>>0)>($612>>>0);
          if ($872) {
           break;
          }
         }
         $873 = ((($$0$i$i$i)) + 8|0);
         $874 = HEAP32[$873>>2]|0;
         $$0$i$i$i = $874;
        }
        $875 = ((($871)) + -47|0);
        $876 = ((($875)) + 8|0);
        $877 = $876;
        $878 = $877 & 7;
        $879 = ($878|0)==(0);
        $880 = (0 - ($877))|0;
        $881 = $880 & 7;
        $882 = $879 ? 0 : $881;
        $883 = (($875) + ($882)|0);
        $884 = ((($612)) + 16|0);
        $885 = ($883>>>0)<($884>>>0);
        $886 = $885 ? $612 : $883;
        $887 = ((($886)) + 8|0);
        $888 = ((($886)) + 24|0);
        $889 = (($$7239$i) + -40)|0;
        $890 = ((($$7$i)) + 8|0);
        $891 = $890;
        $892 = $891 & 7;
        $893 = ($892|0)==(0);
        $894 = (0 - ($891))|0;
        $895 = $894 & 7;
        $896 = $893 ? 0 : $895;
        $897 = (($$7$i) + ($896)|0);
        $898 = (($889) - ($896))|0;
        HEAP32[(27416)>>2] = $897;
        HEAP32[(27404)>>2] = $898;
        $899 = $898 | 1;
        $900 = ((($897)) + 4|0);
        HEAP32[$900>>2] = $899;
        $901 = (($$7$i) + ($889)|0);
        $902 = ((($901)) + 4|0);
        HEAP32[$902>>2] = 40;
        $903 = HEAP32[(27356)>>2]|0;
        HEAP32[(27420)>>2] = $903;
        $904 = ((($886)) + 4|0);
        HEAP32[$904>>2] = 27;
        ;HEAP32[$887>>2]=HEAP32[(27868)>>2]|0;HEAP32[$887+4>>2]=HEAP32[(27868)+4>>2]|0;HEAP32[$887+8>>2]=HEAP32[(27868)+8>>2]|0;HEAP32[$887+12>>2]=HEAP32[(27868)+12>>2]|0;
        HEAP32[(27868)>>2] = $$7$i;
        HEAP32[(27872)>>2] = $$7239$i;
        HEAP32[(27880)>>2] = 0;
        HEAP32[(27876)>>2] = $887;
        $906 = $888;
        while(1) {
         $905 = ((($906)) + 4|0);
         HEAP32[$905>>2] = 7;
         $907 = ((($906)) + 8|0);
         $908 = ($907>>>0)<($871>>>0);
         if ($908) {
          $906 = $905;
         } else {
          break;
         }
        }
        $909 = ($886|0)==($612|0);
        if (!($909)) {
         $910 = $886;
         $911 = $612;
         $912 = (($910) - ($911))|0;
         $913 = HEAP32[$904>>2]|0;
         $914 = $913 & -2;
         HEAP32[$904>>2] = $914;
         $915 = $912 | 1;
         $916 = ((($612)) + 4|0);
         HEAP32[$916>>2] = $915;
         HEAP32[$886>>2] = $912;
         $917 = $912 >>> 3;
         $918 = ($912>>>0)<(256);
         if ($918) {
          $919 = $917 << 1;
          $920 = (27432 + ($919<<2)|0);
          $921 = HEAP32[6848]|0;
          $922 = 1 << $917;
          $923 = $921 & $922;
          $924 = ($923|0)==(0);
          if ($924) {
           $925 = $921 | $922;
           HEAP32[6848] = $925;
           $$pre$i17$i = ((($920)) + 8|0);
           $$0206$i$i = $920;$$pre$phi$i18$iZ2D = $$pre$i17$i;
          } else {
           $926 = ((($920)) + 8|0);
           $927 = HEAP32[$926>>2]|0;
           $$0206$i$i = $927;$$pre$phi$i18$iZ2D = $926;
          }
          HEAP32[$$pre$phi$i18$iZ2D>>2] = $612;
          $928 = ((($$0206$i$i)) + 12|0);
          HEAP32[$928>>2] = $612;
          $929 = ((($612)) + 8|0);
          HEAP32[$929>>2] = $$0206$i$i;
          $930 = ((($612)) + 12|0);
          HEAP32[$930>>2] = $920;
          break;
         }
         $931 = $912 >>> 8;
         $932 = ($931|0)==(0);
         do {
          if ($932) {
           $$0207$i$i = 0;
          } else {
           $933 = ($912>>>0)>(16777215);
           if ($933) {
            $$0207$i$i = 31;
            break;
           }
           $934 = (($931) + 1048320)|0;
           $935 = $934 >>> 16;
           $936 = $935 & 8;
           $937 = $931 << $936;
           $938 = (($937) + 520192)|0;
           $939 = $938 >>> 16;
           $940 = $939 & 4;
           $941 = $940 | $936;
           $942 = $937 << $940;
           $943 = (($942) + 245760)|0;
           $944 = $943 >>> 16;
           $945 = $944 & 2;
           $946 = $941 | $945;
           $947 = (14 - ($946))|0;
           $948 = $942 << $945;
           $949 = $948 >>> 15;
           $950 = (($947) + ($949))|0;
           $951 = $950 << 1;
           $952 = (($950) + 7)|0;
           $953 = $912 >>> $952;
           $954 = $953 & 1;
           $955 = $954 | $951;
           $$0207$i$i = $955;
          }
         } while(0);
         $956 = (27696 + ($$0207$i$i<<2)|0);
         $957 = ((($612)) + 28|0);
         HEAP32[$957>>2] = $$0207$i$i;
         $958 = ((($612)) + 20|0);
         HEAP32[$958>>2] = 0;
         HEAP32[$884>>2] = 0;
         $959 = HEAP32[(27396)>>2]|0;
         $960 = 1 << $$0207$i$i;
         $961 = $959 & $960;
         $962 = ($961|0)==(0);
         if ($962) {
          $963 = $959 | $960;
          HEAP32[(27396)>>2] = $963;
          HEAP32[$956>>2] = $612;
          $964 = ((($612)) + 24|0);
          HEAP32[$964>>2] = $956;
          $965 = ((($612)) + 12|0);
          HEAP32[$965>>2] = $612;
          $966 = ((($612)) + 8|0);
          HEAP32[$966>>2] = $612;
          break;
         }
         $967 = HEAP32[$956>>2]|0;
         $968 = ((($967)) + 4|0);
         $969 = HEAP32[$968>>2]|0;
         $970 = $969 & -8;
         $971 = ($970|0)==($912|0);
         L339: do {
          if ($971) {
           $$0202$lcssa$i$i = $967;
          } else {
           $972 = ($$0207$i$i|0)==(31);
           $973 = $$0207$i$i >>> 1;
           $974 = (25 - ($973))|0;
           $975 = $972 ? 0 : $974;
           $976 = $912 << $975;
           $$02014$i$i = $976;$$02023$i$i = $967;
           while(1) {
            $983 = $$02014$i$i >>> 31;
            $984 = (((($$02023$i$i)) + 16|0) + ($983<<2)|0);
            $979 = HEAP32[$984>>2]|0;
            $985 = ($979|0)==(0|0);
            if ($985) {
             break;
            }
            $977 = $$02014$i$i << 1;
            $978 = ((($979)) + 4|0);
            $980 = HEAP32[$978>>2]|0;
            $981 = $980 & -8;
            $982 = ($981|0)==($912|0);
            if ($982) {
             $$0202$lcssa$i$i = $979;
             break L339;
            } else {
             $$02014$i$i = $977;$$02023$i$i = $979;
            }
           }
           HEAP32[$984>>2] = $612;
           $986 = ((($612)) + 24|0);
           HEAP32[$986>>2] = $$02023$i$i;
           $987 = ((($612)) + 12|0);
           HEAP32[$987>>2] = $612;
           $988 = ((($612)) + 8|0);
           HEAP32[$988>>2] = $612;
           break L230;
          }
         } while(0);
         $989 = ((($$0202$lcssa$i$i)) + 8|0);
         $990 = HEAP32[$989>>2]|0;
         $991 = ((($990)) + 12|0);
         HEAP32[$991>>2] = $612;
         HEAP32[$989>>2] = $612;
         $992 = ((($612)) + 8|0);
         HEAP32[$992>>2] = $990;
         $993 = ((($612)) + 12|0);
         HEAP32[$993>>2] = $$0202$lcssa$i$i;
         $994 = ((($612)) + 24|0);
         HEAP32[$994>>2] = 0;
        }
       }
      } while(0);
      $996 = HEAP32[(27404)>>2]|0;
      $997 = ($996>>>0)>($$0193>>>0);
      if ($997) {
       $998 = (($996) - ($$0193))|0;
       HEAP32[(27404)>>2] = $998;
       $999 = HEAP32[(27416)>>2]|0;
       $1000 = (($999) + ($$0193)|0);
       HEAP32[(27416)>>2] = $1000;
       $1001 = $998 | 1;
       $1002 = ((($1000)) + 4|0);
       HEAP32[$1002>>2] = $1001;
       $1003 = $$0193 | 3;
       $1004 = ((($999)) + 4|0);
       HEAP32[$1004>>2] = $1003;
       $1005 = ((($999)) + 8|0);
       $$2 = $1005;
       break;
      }
     }
    }
    $1006 = (___errno_location()|0);
    HEAP32[$1006>>2] = 12;
    $$2 = 0;
   } else {
    $$2 = 0;
   }
  }
 } while(0);
 $1007 = HEAP32[(27836)>>2]|0;
 $1008 = $1007 & 2;
 $1009 = ($1008|0)==(0);
 if ($1009) {
  $$1 = $$2;
  STACKTOP = sp;return ($$1|0);
 }
 (___pthread_mutex_unlock((27840))|0);
 $$1 = $$2;
 STACKTOP = sp;return ($$1|0);
}
function _free($0) {
 $0 = $0|0;
 var $$0194$i = 0, $$0194$in$i = 0, $$0346381 = 0, $$0347$lcssa = 0, $$0347380 = 0, $$0359 = 0, $$0366 = 0, $$1 = 0, $$1345 = 0, $$1350 = 0, $$1350$be = 0, $$1350$ph = 0, $$1353 = 0, $$1353$be = 0, $$1353$ph = 0, $$1361 = 0, $$1361$be = 0, $$1361$ph = 0, $$1365 = 0, $$1365$be = 0;
 var $$1365$ph = 0, $$2 = 0, $$3 = 0, $$3363 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink395 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0;
 var $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0;
 var $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0;
 var $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0;
 var $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0;
 var $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0;
 var $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0;
 var $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0;
 var $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0;
 var $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0;
 var $272 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0;
 var $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0;
 var $cond371 = 0, $cond372 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ($0|0)==(0|0);
 if ($1) {
  return;
 }
 $2 = ((($0)) + -8|0);
 $3 = HEAP32[(27836)>>2]|0;
 $4 = $3 & 2;
 $5 = ($4|0)==(0);
 if (!($5)) {
  $6 = (___pthread_mutex_lock((27840))|0);
  $7 = ($6|0)==(0);
  if (!($7)) {
   return;
  }
 }
 $8 = HEAP32[(27408)>>2]|0;
 $9 = ((($0)) + -4|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = $10 & -8;
 $12 = (($2) + ($11)|0);
 $13 = $10 & 1;
 $14 = ($13|0)==(0);
 do {
  if ($14) {
   $15 = HEAP32[$2>>2]|0;
   $16 = $10 & 3;
   $17 = ($16|0)==(0);
   if (!($17)) {
    $18 = (0 - ($15))|0;
    $19 = (($2) + ($18)|0);
    $20 = (($15) + ($11))|0;
    $21 = ($19>>>0)<($8>>>0);
    if (!($21)) {
     $22 = HEAP32[(27412)>>2]|0;
     $23 = ($22|0)==($19|0);
     if ($23) {
      $84 = ((($12)) + 4|0);
      $85 = HEAP32[$84>>2]|0;
      $86 = $85 & 3;
      $87 = ($86|0)==(3);
      if (!($87)) {
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
       break;
      }
      $88 = (($19) + ($20)|0);
      $89 = ((($19)) + 4|0);
      $90 = $20 | 1;
      $91 = $85 & -2;
      HEAP32[(27400)>>2] = $20;
      HEAP32[$84>>2] = $91;
      HEAP32[$89>>2] = $90;
      HEAP32[$88>>2] = $20;
      break;
     }
     $24 = $15 >>> 3;
     $25 = ($15>>>0)<(256);
     if ($25) {
      $26 = ((($19)) + 8|0);
      $27 = HEAP32[$26>>2]|0;
      $28 = ((($19)) + 12|0);
      $29 = HEAP32[$28>>2]|0;
      $30 = ($29|0)==($27|0);
      if ($30) {
       $31 = 1 << $24;
       $32 = $31 ^ -1;
       $33 = HEAP32[6848]|0;
       $34 = $33 & $32;
       HEAP32[6848] = $34;
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
       break;
      } else {
       $35 = ((($27)) + 12|0);
       HEAP32[$35>>2] = $29;
       $36 = ((($29)) + 8|0);
       HEAP32[$36>>2] = $27;
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
       break;
      }
     }
     $37 = ((($19)) + 24|0);
     $38 = HEAP32[$37>>2]|0;
     $39 = ((($19)) + 12|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = ($40|0)==($19|0);
     do {
      if ($41) {
       $46 = ((($19)) + 16|0);
       $47 = ((($46)) + 4|0);
       $48 = HEAP32[$47>>2]|0;
       $49 = ($48|0)==(0|0);
       if ($49) {
        $50 = HEAP32[$46>>2]|0;
        $51 = ($50|0)==(0|0);
        if ($51) {
         $$3 = 0;
         break;
        } else {
         $$1350$ph = $50;$$1353$ph = $46;
        }
       } else {
        $$1350$ph = $48;$$1353$ph = $47;
       }
       $$1350 = $$1350$ph;$$1353 = $$1353$ph;
       while(1) {
        $52 = ((($$1350)) + 20|0);
        $53 = HEAP32[$52>>2]|0;
        $54 = ($53|0)==(0|0);
        if ($54) {
         $55 = ((($$1350)) + 16|0);
         $56 = HEAP32[$55>>2]|0;
         $57 = ($56|0)==(0|0);
         if ($57) {
          break;
         } else {
          $$1350$be = $56;$$1353$be = $55;
         }
        } else {
         $$1350$be = $53;$$1353$be = $52;
        }
        $$1350 = $$1350$be;$$1353 = $$1353$be;
       }
       HEAP32[$$1353>>2] = 0;
       $$3 = $$1350;
      } else {
       $42 = ((($19)) + 8|0);
       $43 = HEAP32[$42>>2]|0;
       $44 = ((($43)) + 12|0);
       HEAP32[$44>>2] = $40;
       $45 = ((($40)) + 8|0);
       HEAP32[$45>>2] = $43;
       $$3 = $40;
      }
     } while(0);
     $58 = ($38|0)==(0|0);
     if ($58) {
      $$1 = $19;$$1345 = $20;$92 = $19;
      label = 32;
     } else {
      $59 = ((($19)) + 28|0);
      $60 = HEAP32[$59>>2]|0;
      $61 = (27696 + ($60<<2)|0);
      $62 = HEAP32[$61>>2]|0;
      $63 = ($62|0)==($19|0);
      if ($63) {
       HEAP32[$61>>2] = $$3;
       $cond371 = ($$3|0)==(0|0);
       if ($cond371) {
        $64 = 1 << $60;
        $65 = $64 ^ -1;
        $66 = HEAP32[(27396)>>2]|0;
        $67 = $66 & $65;
        HEAP32[(27396)>>2] = $67;
        $$1 = $19;$$1345 = $20;$92 = $19;
        label = 32;
        break;
       }
      } else {
       $68 = ((($38)) + 16|0);
       $69 = HEAP32[$68>>2]|0;
       $70 = ($69|0)==($19|0);
       $71 = ((($38)) + 20|0);
       $$sink = $70 ? $68 : $71;
       HEAP32[$$sink>>2] = $$3;
       $72 = ($$3|0)==(0|0);
       if ($72) {
        $$1 = $19;$$1345 = $20;$92 = $19;
        label = 32;
        break;
       }
      }
      $73 = ((($$3)) + 24|0);
      HEAP32[$73>>2] = $38;
      $74 = ((($19)) + 16|0);
      $75 = HEAP32[$74>>2]|0;
      $76 = ($75|0)==(0|0);
      if (!($76)) {
       $77 = ((($$3)) + 16|0);
       HEAP32[$77>>2] = $75;
       $78 = ((($75)) + 24|0);
       HEAP32[$78>>2] = $$3;
      }
      $79 = ((($74)) + 4|0);
      $80 = HEAP32[$79>>2]|0;
      $81 = ($80|0)==(0|0);
      if ($81) {
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
      } else {
       $82 = ((($$3)) + 20|0);
       HEAP32[$82>>2] = $80;
       $83 = ((($80)) + 24|0);
       HEAP32[$83>>2] = $$3;
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
      }
     }
    }
   }
  } else {
   $$1 = $2;$$1345 = $11;$92 = $2;
   label = 32;
  }
 } while(0);
 do {
  if ((label|0) == 32) {
   $93 = ($92>>>0)<($12>>>0);
   if ($93) {
    $94 = ((($12)) + 4|0);
    $95 = HEAP32[$94>>2]|0;
    $96 = $95 & 1;
    $97 = ($96|0)==(0);
    if (!($97)) {
     $98 = $95 & 2;
     $99 = ($98|0)==(0);
     if ($99) {
      $100 = HEAP32[(27416)>>2]|0;
      $101 = ($100|0)==($12|0);
      if ($101) {
       $102 = HEAP32[(27404)>>2]|0;
       $103 = (($102) + ($$1345))|0;
       HEAP32[(27404)>>2] = $103;
       HEAP32[(27416)>>2] = $$1;
       $104 = $103 | 1;
       $105 = ((($$1)) + 4|0);
       HEAP32[$105>>2] = $104;
       $106 = HEAP32[(27412)>>2]|0;
       $107 = ($$1|0)==($106|0);
       if (!($107)) {
        break;
       }
       HEAP32[(27412)>>2] = 0;
       HEAP32[(27400)>>2] = 0;
       break;
      }
      $108 = HEAP32[(27412)>>2]|0;
      $109 = ($108|0)==($12|0);
      if ($109) {
       $110 = HEAP32[(27400)>>2]|0;
       $111 = (($110) + ($$1345))|0;
       HEAP32[(27400)>>2] = $111;
       HEAP32[(27412)>>2] = $92;
       $112 = $111 | 1;
       $113 = ((($$1)) + 4|0);
       HEAP32[$113>>2] = $112;
       $114 = (($92) + ($111)|0);
       HEAP32[$114>>2] = $111;
       break;
      }
      $115 = $95 & -8;
      $116 = (($115) + ($$1345))|0;
      $117 = $95 >>> 3;
      $118 = ($95>>>0)<(256);
      do {
       if ($118) {
        $119 = ((($12)) + 8|0);
        $120 = HEAP32[$119>>2]|0;
        $121 = ((($12)) + 12|0);
        $122 = HEAP32[$121>>2]|0;
        $123 = ($122|0)==($120|0);
        if ($123) {
         $124 = 1 << $117;
         $125 = $124 ^ -1;
         $126 = HEAP32[6848]|0;
         $127 = $126 & $125;
         HEAP32[6848] = $127;
         break;
        } else {
         $128 = ((($120)) + 12|0);
         HEAP32[$128>>2] = $122;
         $129 = ((($122)) + 8|0);
         HEAP32[$129>>2] = $120;
         break;
        }
       } else {
        $130 = ((($12)) + 24|0);
        $131 = HEAP32[$130>>2]|0;
        $132 = ((($12)) + 12|0);
        $133 = HEAP32[$132>>2]|0;
        $134 = ($133|0)==($12|0);
        do {
         if ($134) {
          $139 = ((($12)) + 16|0);
          $140 = ((($139)) + 4|0);
          $141 = HEAP32[$140>>2]|0;
          $142 = ($141|0)==(0|0);
          if ($142) {
           $143 = HEAP32[$139>>2]|0;
           $144 = ($143|0)==(0|0);
           if ($144) {
            $$3363 = 0;
            break;
           } else {
            $$1361$ph = $143;$$1365$ph = $139;
           }
          } else {
           $$1361$ph = $141;$$1365$ph = $140;
          }
          $$1361 = $$1361$ph;$$1365 = $$1365$ph;
          while(1) {
           $145 = ((($$1361)) + 20|0);
           $146 = HEAP32[$145>>2]|0;
           $147 = ($146|0)==(0|0);
           if ($147) {
            $148 = ((($$1361)) + 16|0);
            $149 = HEAP32[$148>>2]|0;
            $150 = ($149|0)==(0|0);
            if ($150) {
             break;
            } else {
             $$1361$be = $149;$$1365$be = $148;
            }
           } else {
            $$1361$be = $146;$$1365$be = $145;
           }
           $$1361 = $$1361$be;$$1365 = $$1365$be;
          }
          HEAP32[$$1365>>2] = 0;
          $$3363 = $$1361;
         } else {
          $135 = ((($12)) + 8|0);
          $136 = HEAP32[$135>>2]|0;
          $137 = ((($136)) + 12|0);
          HEAP32[$137>>2] = $133;
          $138 = ((($133)) + 8|0);
          HEAP32[$138>>2] = $136;
          $$3363 = $133;
         }
        } while(0);
        $151 = ($131|0)==(0|0);
        if (!($151)) {
         $152 = ((($12)) + 28|0);
         $153 = HEAP32[$152>>2]|0;
         $154 = (27696 + ($153<<2)|0);
         $155 = HEAP32[$154>>2]|0;
         $156 = ($155|0)==($12|0);
         if ($156) {
          HEAP32[$154>>2] = $$3363;
          $cond372 = ($$3363|0)==(0|0);
          if ($cond372) {
           $157 = 1 << $153;
           $158 = $157 ^ -1;
           $159 = HEAP32[(27396)>>2]|0;
           $160 = $159 & $158;
           HEAP32[(27396)>>2] = $160;
           break;
          }
         } else {
          $161 = ((($131)) + 16|0);
          $162 = HEAP32[$161>>2]|0;
          $163 = ($162|0)==($12|0);
          $164 = ((($131)) + 20|0);
          $$sink395 = $163 ? $161 : $164;
          HEAP32[$$sink395>>2] = $$3363;
          $165 = ($$3363|0)==(0|0);
          if ($165) {
           break;
          }
         }
         $166 = ((($$3363)) + 24|0);
         HEAP32[$166>>2] = $131;
         $167 = ((($12)) + 16|0);
         $168 = HEAP32[$167>>2]|0;
         $169 = ($168|0)==(0|0);
         if (!($169)) {
          $170 = ((($$3363)) + 16|0);
          HEAP32[$170>>2] = $168;
          $171 = ((($168)) + 24|0);
          HEAP32[$171>>2] = $$3363;
         }
         $172 = ((($167)) + 4|0);
         $173 = HEAP32[$172>>2]|0;
         $174 = ($173|0)==(0|0);
         if (!($174)) {
          $175 = ((($$3363)) + 20|0);
          HEAP32[$175>>2] = $173;
          $176 = ((($173)) + 24|0);
          HEAP32[$176>>2] = $$3363;
         }
        }
       }
      } while(0);
      $177 = $116 | 1;
      $178 = ((($$1)) + 4|0);
      HEAP32[$178>>2] = $177;
      $179 = (($92) + ($116)|0);
      HEAP32[$179>>2] = $116;
      $180 = HEAP32[(27412)>>2]|0;
      $181 = ($$1|0)==($180|0);
      if ($181) {
       HEAP32[(27400)>>2] = $116;
       break;
      } else {
       $$2 = $116;
      }
     } else {
      $182 = $95 & -2;
      HEAP32[$94>>2] = $182;
      $183 = $$1345 | 1;
      $184 = ((($$1)) + 4|0);
      HEAP32[$184>>2] = $183;
      $185 = (($92) + ($$1345)|0);
      HEAP32[$185>>2] = $$1345;
      $$2 = $$1345;
     }
     $186 = $$2 >>> 3;
     $187 = ($$2>>>0)<(256);
     if ($187) {
      $188 = $186 << 1;
      $189 = (27432 + ($188<<2)|0);
      $190 = HEAP32[6848]|0;
      $191 = 1 << $186;
      $192 = $190 & $191;
      $193 = ($192|0)==(0);
      if ($193) {
       $194 = $190 | $191;
       HEAP32[6848] = $194;
       $$pre = ((($189)) + 8|0);
       $$0366 = $189;$$pre$phiZ2D = $$pre;
      } else {
       $195 = ((($189)) + 8|0);
       $196 = HEAP32[$195>>2]|0;
       $$0366 = $196;$$pre$phiZ2D = $195;
      }
      HEAP32[$$pre$phiZ2D>>2] = $$1;
      $197 = ((($$0366)) + 12|0);
      HEAP32[$197>>2] = $$1;
      $198 = ((($$1)) + 8|0);
      HEAP32[$198>>2] = $$0366;
      $199 = ((($$1)) + 12|0);
      HEAP32[$199>>2] = $189;
      break;
     }
     $200 = $$2 >>> 8;
     $201 = ($200|0)==(0);
     if ($201) {
      $$0359 = 0;
     } else {
      $202 = ($$2>>>0)>(16777215);
      if ($202) {
       $$0359 = 31;
      } else {
       $203 = (($200) + 1048320)|0;
       $204 = $203 >>> 16;
       $205 = $204 & 8;
       $206 = $200 << $205;
       $207 = (($206) + 520192)|0;
       $208 = $207 >>> 16;
       $209 = $208 & 4;
       $210 = $209 | $205;
       $211 = $206 << $209;
       $212 = (($211) + 245760)|0;
       $213 = $212 >>> 16;
       $214 = $213 & 2;
       $215 = $210 | $214;
       $216 = (14 - ($215))|0;
       $217 = $211 << $214;
       $218 = $217 >>> 15;
       $219 = (($216) + ($218))|0;
       $220 = $219 << 1;
       $221 = (($219) + 7)|0;
       $222 = $$2 >>> $221;
       $223 = $222 & 1;
       $224 = $223 | $220;
       $$0359 = $224;
      }
     }
     $225 = (27696 + ($$0359<<2)|0);
     $226 = ((($$1)) + 28|0);
     HEAP32[$226>>2] = $$0359;
     $227 = ((($$1)) + 16|0);
     $228 = ((($$1)) + 20|0);
     HEAP32[$228>>2] = 0;
     HEAP32[$227>>2] = 0;
     $229 = HEAP32[(27396)>>2]|0;
     $230 = 1 << $$0359;
     $231 = $229 & $230;
     $232 = ($231|0)==(0);
     L102: do {
      if ($232) {
       $233 = $229 | $230;
       HEAP32[(27396)>>2] = $233;
       HEAP32[$225>>2] = $$1;
       $234 = ((($$1)) + 24|0);
       HEAP32[$234>>2] = $225;
       $235 = ((($$1)) + 12|0);
       HEAP32[$235>>2] = $$1;
       $236 = ((($$1)) + 8|0);
       HEAP32[$236>>2] = $$1;
      } else {
       $237 = HEAP32[$225>>2]|0;
       $238 = ((($237)) + 4|0);
       $239 = HEAP32[$238>>2]|0;
       $240 = $239 & -8;
       $241 = ($240|0)==($$2|0);
       L105: do {
        if ($241) {
         $$0347$lcssa = $237;
        } else {
         $242 = ($$0359|0)==(31);
         $243 = $$0359 >>> 1;
         $244 = (25 - ($243))|0;
         $245 = $242 ? 0 : $244;
         $246 = $$2 << $245;
         $$0346381 = $246;$$0347380 = $237;
         while(1) {
          $253 = $$0346381 >>> 31;
          $254 = (((($$0347380)) + 16|0) + ($253<<2)|0);
          $249 = HEAP32[$254>>2]|0;
          $255 = ($249|0)==(0|0);
          if ($255) {
           break;
          }
          $247 = $$0346381 << 1;
          $248 = ((($249)) + 4|0);
          $250 = HEAP32[$248>>2]|0;
          $251 = $250 & -8;
          $252 = ($251|0)==($$2|0);
          if ($252) {
           $$0347$lcssa = $249;
           break L105;
          } else {
           $$0346381 = $247;$$0347380 = $249;
          }
         }
         HEAP32[$254>>2] = $$1;
         $256 = ((($$1)) + 24|0);
         HEAP32[$256>>2] = $$0347380;
         $257 = ((($$1)) + 12|0);
         HEAP32[$257>>2] = $$1;
         $258 = ((($$1)) + 8|0);
         HEAP32[$258>>2] = $$1;
         break L102;
        }
       } while(0);
       $259 = ((($$0347$lcssa)) + 8|0);
       $260 = HEAP32[$259>>2]|0;
       $261 = ((($260)) + 12|0);
       HEAP32[$261>>2] = $$1;
       HEAP32[$259>>2] = $$1;
       $262 = ((($$1)) + 8|0);
       HEAP32[$262>>2] = $260;
       $263 = ((($$1)) + 12|0);
       HEAP32[$263>>2] = $$0347$lcssa;
       $264 = ((($$1)) + 24|0);
       HEAP32[$264>>2] = 0;
      }
     } while(0);
     $265 = HEAP32[(27424)>>2]|0;
     $266 = (($265) + -1)|0;
     HEAP32[(27424)>>2] = $266;
     $267 = ($266|0)==(0);
     if ($267) {
      $$0194$in$i = (27876);
      while(1) {
       $$0194$i = HEAP32[$$0194$in$i>>2]|0;
       $268 = ($$0194$i|0)==(0|0);
       $269 = ((($$0194$i)) + 8|0);
       if ($268) {
        break;
       } else {
        $$0194$in$i = $269;
       }
      }
      HEAP32[(27424)>>2] = -1;
     }
    }
   }
  }
 } while(0);
 $270 = HEAP32[(27836)>>2]|0;
 $271 = $270 & 2;
 $272 = ($271|0)==(0);
 if ($272) {
  return;
 }
 (___pthread_mutex_unlock((27840))|0);
 return;
}
function _sbrk(increment) {
    increment = increment|0;
    var oldDynamicTop = 0;
    var oldDynamicTopOnChange = 0;
    var newDynamicTop = 0;
    var totalMemory = 0;
    totalMemory = _emscripten_get_heap_size()|0;
    // Perform a compare-and-swap loop to update the new dynamic top value. This is because
    // this function can be called simultaneously in multiple threads.
    do {

      oldDynamicTop = Atomics_load(HEAP32, DYNAMICTOP_PTR>>2)|0;
      newDynamicTop = oldDynamicTop + increment | 0;

      if (((increment|0) > 0 & (newDynamicTop|0) < (oldDynamicTop|0)) // Detect and fail if we would wrap around signed 32-bit int.
        | (newDynamicTop|0) < 0) { // Also underflow, sbrk() should be able to be used to subtract.
        abortOnCannotGrowMemory(newDynamicTop|0)|0;
        ___setErrNo(12);
        return -1;
      }

      if ((newDynamicTop|0) > (totalMemory|0)) {
        if (_emscripten_resize_heap(newDynamicTop|0)|0) {
          // We resized the heap. Start another loop iteration if we need to.
          totalMemory = _emscripten_get_heap_size()|0;
          continue;
        } else {
          // We failed to resize the heap.
          // Possibly another thread has grown memory meanwhile, if we race with them. If memory grew,
          // start another loop iteration.
          if ((_emscripten_get_heap_size()|0) > totalMemory) {
            totalMemory = _emscripten_get_heap_size()|0;
            continue;
          }
          ___setErrNo(12);
          return -1;
        }
      }

      // Attempt to update the dynamic top to new value. Another thread may have beat this thread to the update,
      // in which case we will need to start over by iterating the loop body again.
      oldDynamicTopOnChange = Atomics_compareExchange(HEAP32, DYNAMICTOP_PTR>>2, oldDynamicTop|0, newDynamicTop|0)|0;
    } while((oldDynamicTopOnChange|0) != (oldDynamicTop|0));

    return oldDynamicTop|0;
}
function ___pthread_mutex_lock($0) {
 $0 = $0|0;
 var $$0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = HEAP32[$0>>2]|0;
 $2 = $1 & 15;
 $3 = ($2|0)==(0);
 if ($3) {
  $4 = ((($0)) + 4|0);
  $5 = (Atomics_compareExchange(HEAP32, $4>>2,0,16)|0);
  $6 = ($5|0)==(0);
  if ($6) {
   $$0 = 0;
   return ($$0|0);
  }
 }
 $7 = (___pthread_mutex_timedlock($0,0)|0);
 $$0 = $7;
 return ($$0|0);
}
function ___pthread_mutex_unlock($0) {
 $0 = $0|0;
 var $$0 = 0, $$045 = 0, $$pre = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0;
 var $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ((($0)) + 8|0);
 $2 = (Atomics_load(HEAP32,$1>>2)|0);
 $3 = HEAP32[$0>>2]|0;
 $4 = $3 & 15;
 $5 = $3 & 128;
 $6 = $5 ^ 128;
 $7 = ($4|0)==(0);
 if ($7) {
  $$pre = ((($0)) + 4|0);
  $$045 = 0;$$pre$phiZ2D = $$pre;
 } else {
  $8 = (_pthread_self()|0);
  $9 = ((($0)) + 4|0);
  $10 = (Atomics_load(HEAP32,$9>>2)|0);
  $11 = $10 & 2147483647;
  $12 = ((($8)) + 52|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ($11|0)==($13|0);
  if (!($14)) {
   $$0 = 1;
   return ($$0|0);
  }
  $15 = $3 & 3;
  $16 = ($15|0)==(1);
  if ($16) {
   $17 = ((($0)) + 20|0);
   $18 = HEAP32[$17>>2]|0;
   $19 = ($18|0)==(0);
   if (!($19)) {
    $20 = (($18) + -1)|0;
    HEAP32[$17>>2] = $20;
    $$0 = 0;
    return ($$0|0);
   }
  }
  $21 = ($6|0)==(0);
  $22 = ((($0)) + 16|0);
  if ($21) {
   $23 = ((($8)) + 176|0);
   Atomics_store(HEAP32,$23>>2,$22)|0;
   ___vm_lock();
  }
  $24 = ((($0)) + 12|0);
  $25 = HEAP32[$24>>2]|0;
  $26 = HEAP32[$22>>2]|0;
  Atomics_store(HEAP32,$25>>2,$26)|0;
  $27 = ((($8)) + 168|0);
  $28 = ($26|0)==($27|0);
  if ($28) {
   $$045 = $8;$$pre$phiZ2D = $9;
  } else {
   $29 = ((($26)) + -4|0);
   Atomics_store(HEAP32,$29>>2,$25)|0;
   $$045 = $8;$$pre$phiZ2D = $9;
  }
 }
 $30 = $3 & 8;
 $31 = ($30|0)==(0);
 $32 = $31 ? 0 : 2147483647;
 while(1) {
  $33 = (Atomics_load(HEAP32, $$pre$phiZ2D>>2)|0);
  $34 = (Atomics_compareExchange(HEAP32, $$pre$phiZ2D>>2,$33,$32)|0);
  $35 = ($34|0)==($33|0);
  if ($35) {
   break;
  }
 }
 $36 = ($6|0)!=(0);
 $or$cond = $7 | $36;
 if (!($or$cond)) {
  $37 = ((($$045)) + 176|0);
  Atomics_store(HEAP32,$37>>2,0)|0;
  ___vm_unlock();
 }
 $38 = ($2|0)!=(0);
 $39 = ($33|0)<(0);
 $or$cond3 = $38 | $39;
 if (!($or$cond3)) {
  $$0 = 0;
  return ($$0|0);
 }
 (_emscripten_futex_wake(($$pre$phiZ2D|0),1)|0);
 $$0 = 0;
 return ($$0|0);
}
function _pthread_mutexattr_init($0) {
 $0 = $0|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 HEAP32[$0>>2] = 0;
 return 0;
}
function _pthread_mutex_init($0,$1) {
 $0 = $0|0;
 $1 = $1|0;
 var $$sroa$0 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abortStackOverflow(32|0);
 $$sroa$0 = sp;
 ;HEAP32[$$sroa$0>>2]=0|0;HEAP32[$$sroa$0+4>>2]=0|0;HEAP32[$$sroa$0+8>>2]=0|0;HEAP32[$$sroa$0+12>>2]=0|0;HEAP32[$$sroa$0+16>>2]=0|0;HEAP32[$$sroa$0+20>>2]=0|0;HEAP32[$$sroa$0+24>>2]=0|0;
 ;HEAP32[$0>>2]=HEAP32[$$sroa$0>>2]|0;HEAP32[$0+4>>2]=HEAP32[$$sroa$0+4>>2]|0;HEAP32[$0+8>>2]=HEAP32[$$sroa$0+8>>2]|0;HEAP32[$0+12>>2]=HEAP32[$$sroa$0+12>>2]|0;HEAP32[$0+16>>2]=HEAP32[$$sroa$0+16>>2]|0;HEAP32[$0+20>>2]=HEAP32[$$sroa$0+20>>2]|0;HEAP32[$0+24>>2]=HEAP32[$$sroa$0+24>>2]|0;
 $2 = ($1|0)==(0|0);
 if ($2) {
  STACKTOP = sp;return 0;
 }
 $3 = HEAP32[$1>>2]|0;
 HEAP32[$0>>2] = $3;
 STACKTOP = sp;return 0;
}
// Copyright 2016 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.


// Copyright 2016 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

var Fetch = {
  xhrs: [],

  // The web worker that runs proxied file I/O requests. (this field is populated on demand, start as undefined to save code size)
  // worker: undefined,

  // Specifies an instance to the IndexedDB database. The database is opened
  // as a preload step before the Emscripten application starts. (this field is populated on demand, start as undefined to save code size)
  // dbInstance: undefined,

  setu64: function(addr, val) {
    HEAPU32[addr >> 2] = val;
    HEAPU32[addr + 4 >> 2] = (val / 4294967296)|0;
  },

  openDatabase: function(dbname, dbversion, onsuccess, onerror) {
    try {
      var openRequest = indexedDB.open(dbname, dbversion);
    } catch (e) { return onerror(e); }

    openRequest.onupgradeneeded = function(event) {
      var db = event.target.result;
      if (db.objectStoreNames.contains('FILES')) {
        db.deleteObjectStore('FILES');
      }
      db.createObjectStore('FILES');
    };
    openRequest.onsuccess = function(event) { onsuccess(event.target.result); };
    openRequest.onerror = function(error) { onerror(error); };
  },

  initFetchWorker: function() {
    var stackSize = 128*1024;
    var stack = allocate(stackSize>>2, "i32*", ALLOC_DYNAMIC);
    Fetch.worker.postMessage({cmd: 'init', DYNAMICTOP_PTR: DYNAMICTOP_PTR, STACKTOP: stack, STACK_MAX: stack + stackSize, queuePtr: _fetch_work_queue, buffer: HEAPU8.buffer});
  },

  staticInit: function() {
    var isMainThread = (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' && !ENVIRONMENT_IS_PTHREAD);

    var onsuccess = function(db) {
      Fetch.dbInstance = db;

      if (isMainThread) {
        Fetch.initFetchWorker();
        removeRunDependency('library_fetch_init');
      }
    };
    var onerror = function() {
      Fetch.dbInstance = false;

      if (isMainThread) {
        Fetch.initFetchWorker();
        removeRunDependency('library_fetch_init');
      }
    };
    Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);

    if (isMainThread) {
      addRunDependency('library_fetch_init');

      // Allow HTML module to configure the location where the 'worker.js' file will be loaded from,
      // via Module.locateFile() function. If not specified, then the default URL 'worker.js' relative
      // to the main html file is loaded.
      var fetchJs = locateFile('index.fetch.js');
      Fetch.worker = new Worker(fetchJs);
      Fetch.worker.onmessage = function(e) {
        out('fetch-worker sent a message: ' + e.filename + ':' + e.lineno + ': ' + e.message);
      };
      Fetch.worker.onerror = function(e) {
        err('fetch-worker sent an error! ' + e.filename + ':' + e.lineno + ': ' + e.message);
      };
    }
  }
}

function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {
    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + 112;
  var path = HEAPU32[fetch_attr + 60 >> 2];
  if (!path) path = HEAPU32[fetch + 8 >> 2];
  var pathStr = UTF8ToString(path);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var request = packages.delete(pathStr);
    request.onsuccess = function(event) {
      var value = event.target.result;
      HEAPU32[fetch + 12 >> 2] = 0;
      Fetch.setu64(fetch + 16, 0);
      Fetch.setu64(fetch + 24, 0);
      Fetch.setu64(fetch + 32, 0);
      HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + 44, 64);
      onsuccess(fetch, 0, value);
    };
    request.onerror = function(error) {
      HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + 44, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {
    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {
    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + 112;
  var path = HEAPU32[fetch_attr + 60 >> 2];
  if (!path) path = HEAPU32[fetch + 8 >> 2];
  var pathStr = UTF8ToString(path);

  try {
    var transaction = db.transaction(['FILES'], 'readonly');
    var packages = transaction.objectStore('FILES');
    var getRequest = packages.get(pathStr);
    getRequest.onsuccess = function(event) {
      if (event.target.result) {
        var value = event.target.result;
        var len = value.byteLength || value.length;
        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        var ptr = _malloc(len);
        HEAPU8.set(new Uint8Array(value), ptr);
        HEAPU32[fetch + 12 >> 2] = ptr;
        Fetch.setu64(fetch + 16, len);
        Fetch.setu64(fetch + 24, 0);
        Fetch.setu64(fetch + 32, len);
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + 44, 64);
        onsuccess(fetch, 0, value);
      } else {
        // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.
        HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + 44, 64);
        onerror(fetch, 0, 'no data');
      }
    };
    getRequest.onerror = function(error) {
      HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + 44, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {
    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
  if (!db) {
    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + 112;
  var destinationPath = HEAPU32[fetch_attr + 60 >> 2];
  if (!destinationPath) destinationPath = HEAPU32[fetch + 8 >> 2];
  var destinationPathStr = UTF8ToString(destinationPath);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var putRequest = packages.put(data, destinationPathStr);
    putRequest.onsuccess = function(event) {
      HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + 44, 64);
      onsuccess(fetch, 0, destinationPathStr);
    };
    putRequest.onerror = function(error) {
      // Most likely we got an error if IndexedDB is unwilling to store any more data for this page.
      // TODO: Can we identify and break down different IndexedDB-provided errors and convert those
      // to more HTTP status codes for more information?
      HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + 42 >> 1] = 413; // Mimic XHR HTTP status code 413 "Payload Too Large"
      stringToUTF8("Payload Too Large", fetch + 44, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {
    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress) {
  var url = HEAPU32[fetch + 8 >> 2];
  if (!url) {
    onerror(fetch, 0, 'no url specified!');
    return;
  }
  var url_ = UTF8ToString(url);

  var fetch_attr = fetch + 112;
  var requestMethod = UTF8ToString(fetch_attr);
  if (!requestMethod) requestMethod = 'GET';
  var userData = HEAPU32[fetch_attr + 32 >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + 48 >> 2];
  var timeoutMsecs = HEAPU32[fetch_attr + 52 >> 2];
  var withCredentials = !!HEAPU32[fetch_attr + 56 >> 2];
  var destinationPath = HEAPU32[fetch_attr + 60 >> 2];
  var userName = HEAPU32[fetch_attr + 64 >> 2];
  var password = HEAPU32[fetch_attr + 68 >> 2];
  var requestHeaders = HEAPU32[fetch_attr + 72 >> 2];
  var overriddenMimeType = HEAPU32[fetch_attr + 76 >> 2];
  var dataPtr = HEAPU32[fetch_attr + 80 >> 2];
  var dataLength = HEAPU32[fetch_attr + 84 >> 2];

  var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
  var fetchAttrStreamData = !!(fetchAttributes & 2);
  var fetchAttrPersistFile = !!(fetchAttributes & 4);
  var fetchAttrAppend = !!(fetchAttributes & 8);
  var fetchAttrReplace = !!(fetchAttributes & 16);
  var fetchAttrSynchronous = !!(fetchAttributes & 64);
  var fetchAttrWaitable = !!(fetchAttributes & 128);

  var userNameStr = userName ? UTF8ToString(userName) : undefined;
  var passwordStr = password ? UTF8ToString(password) : undefined;
  var overriddenMimeTypeStr = overriddenMimeType ? UTF8ToString(overriddenMimeType) : undefined;

  var xhr = new XMLHttpRequest();
  xhr.withCredentials = withCredentials;
  xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
  if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
  xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
  xhr.responseType = fetchAttrStreamData ? 'moz-chunked-arraybuffer' : 'arraybuffer';

  if (overriddenMimeType) {
    xhr.overrideMimeType(overriddenMimeTypeStr);
  }
  if (requestHeaders) {
    for(;;) {
      var key = HEAPU32[requestHeaders >> 2];
      if (!key) break;
      var value = HEAPU32[requestHeaders + 4 >> 2];
      if (!value) break;
      requestHeaders += 8;
      var keyStr = UTF8ToString(key);
      var valueStr = UTF8ToString(value);
      xhr.setRequestHeader(keyStr, valueStr);
    }
  }
  Fetch.xhrs.push(xhr);
  var id = Fetch.xhrs.length;
  HEAPU32[fetch + 0 >> 2] = id;
  var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
  // TODO: Support specifying custom headers to the request.

  xhr.onload = function(e) {
    var len = xhr.response ? xhr.response.byteLength : 0;
    var ptr = 0;
    var ptrLen = 0;
    if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
      ptrLen = len;
      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + 12 >> 2] = ptr;
    Fetch.setu64(fetch + 16, ptrLen);
    Fetch.setu64(fetch + 24, 0);
    if (len) {
      // If the final XHR.onload handler receives the bytedata to compute total length, report that,
      // otherwise don't write anything out here, which will retain the latest byte size reported in
      // the most recent XHR.onprogress handler.
      Fetch.setu64(fetch + 32, len);
    }
    HEAPU16[fetch + 40 >> 1] = xhr.readyState;
    if (xhr.readyState === 4 && xhr.status === 0) {
      if (len > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we got data bytes.
      else xhr.status = 404; // Conversely, no data bytes is 404.
    }
    HEAPU16[fetch + 42 >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
    if (xhr.status >= 200 && xhr.status < 300) {
      if (onsuccess) onsuccess(fetch, xhr, e);
    } else {
      if (onerror) onerror(fetch, xhr, e);
    }
  }
  xhr.onerror = function(e) {
    var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
    if (xhr.readyState == 4 && status == 0) status = 404; // If no error recorded, pretend it was 404 Not Found.
    HEAPU32[fetch + 12 >> 2] = 0;
    Fetch.setu64(fetch + 16, 0);
    Fetch.setu64(fetch + 24, 0);
    Fetch.setu64(fetch + 32, 0);
    HEAPU16[fetch + 40 >> 1] = xhr.readyState;
    HEAPU16[fetch + 42 >> 1] = status;
    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.ontimeout = function(e) {
    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.onprogress = function(e) {
    var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
    var ptr = 0;
    if (fetchAttrLoadToMemory && fetchAttrStreamData) {
      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + 12 >> 2] = ptr;
    Fetch.setu64(fetch + 16, ptrLen);
    Fetch.setu64(fetch + 24, e.loaded - ptrLen);
    Fetch.setu64(fetch + 32, e.total);
    HEAPU16[fetch + 40 >> 1] = xhr.readyState;
    if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
    HEAPU16[fetch + 42 >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
    if (onprogress) onprogress(fetch, xhr, e);
  }
  try {
    xhr.send(data);
  } catch(e) {
    if (onerror) onerror(fetch, xhr, e);
  }
}

function emscripten_start_fetch(fetch, successcb, errorcb, progresscb) {
  if (typeof Module !== 'undefined') Module['noExitRuntime'] = true; // If we are the main Emscripten runtime, we should not be closing down.

  var fetch_attr = fetch + 112;
  var requestMethod = UTF8ToString(fetch_attr);
  var onsuccess = HEAPU32[fetch_attr + 36 >> 2];
  var onerror = HEAPU32[fetch_attr + 40 >> 2];
  var onprogress = HEAPU32[fetch_attr + 44 >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + 48 >> 2];
  var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
  var fetchAttrStreamData = !!(fetchAttributes & 2);
  var fetchAttrPersistFile = !!(fetchAttributes & 4);
  var fetchAttrNoDownload = !!(fetchAttributes & 32);
  var fetchAttrAppend = !!(fetchAttributes & 8);
  var fetchAttrReplace = !!(fetchAttributes & 16);

  var reportSuccess = function(fetch, xhr, e) {
    if (onsuccess) dynCall_vi(onsuccess, fetch);
    else if (successcb) successcb(fetch);
  };

  var reportProgress = function(fetch, xhr, e) {
    if (onprogress) dynCall_vi(onprogress, fetch);
    else if (progresscb) progresscb(fetch);
  };

  var reportError = function(fetch, xhr, e) {
    if (onerror) dynCall_vi(onerror, fetch);
    else if (errorcb) errorcb(fetch);
  };

  var performUncachedXhr = function(fetch, xhr, e) {
    __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
  };

  var cacheResultAndReportSuccess = function(fetch, xhr, e) {
    var storeSuccess = function(fetch, xhr, e) {
      if (onsuccess) dynCall_vi(onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    var storeError = function(fetch, xhr, e) {
      if (onsuccess) dynCall_vi(onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
  };

  var performCachedXhr = function(fetch, xhr, e) {
    __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
  };

  // Should we try IndexedDB first?
  var needsIndexedDbConnection = !fetchAttrReplace || requestMethod === 'EM_IDB_STORE' || requestMethod === 'EM_IDB_DELETE';
  if (needsIndexedDbConnection && !Fetch.dbInstance) {
    reportError(fetch, 0, 'IndexedDB is not open');
    return 0; // todo: free
  }

  if (requestMethod === 'EM_IDB_STORE') {
    // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
    var ptr = HEAPU32[fetch_attr + 80 >> 2];
    __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, HEAPU8.slice(ptr, ptr + HEAPU32[fetch_attr + 84 >> 2]), reportSuccess, reportError);
  } else if (requestMethod === 'EM_IDB_DELETE') {
    __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
  } else if (!fetchAttrReplace) {
    __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, fetchAttrNoDownload ? reportError : (fetchAttrPersistFile ? performCachedXhr : performUncachedXhr));
  } else if (!fetchAttrNoDownload) {
    __emscripten_fetch_xhr(fetch, fetchAttrPersistFile ? cacheResultAndReportSuccess : reportSuccess, reportError, reportProgress);
  } else {
    return 0; // todo: free
  }
  return fetch;
}



if (typeof Atomics === 'undefined') {
  // Polyfill singlethreaded atomics ops from http://lars-t-hansen.github.io/ecmascript_sharedmem/shmem.html#Atomics.add
  // No thread-safety needed since we don't have multithreading support.
  Atomics = {};
  Atomics['add'] = function(t, i, v) { var w = t[i]; t[i] += v; return w; }
  Atomics['and'] = function(t, i, v) { var w = t[i]; t[i] &= v; return w; }
  Atomics['compareExchange'] = function(t, i, e, r) { var w = t[i]; if (w == e) t[i] = r; return w; }
  Atomics['exchange'] = function(t, i, v) { var w = t[i]; t[i] = v; return w; }
  Atomics['wait'] = function(t, i, v, o) { if (t[i] != v) return 'not-equal'; else return 'timed-out'; }
  Atomics['notify'] = function(t, i, c) { return 0; }
  Atomics['wakeOrRequeue'] = function(t, i1, c, i2, v) { return 0; }
  Atomics['isLockFree'] = function(s) { return true; }
  Atomics['load'] = function(t, i) { return t[i]; }
  Atomics['or'] = function(t, i, v) { var w = t[i]; t[i] |= v; return w; }
  Atomics['store'] = function(t, i, v) { t[i] = v; return v; }
  Atomics['sub'] = function(t, i, v) { var w = t[i]; t[i] -= v; return w; }
  Atomics['xor'] = function(t, i, v) { var w = t[i]; t[i] ^= v; return w; }
}

var Atomics_add = Atomics.add;
var Atomics_and = Atomics.and;
var Atomics_compareExchange = Atomics.compareExchange;
var Atomics_exchange = Atomics.exchange;
var Atomics_wait = Atomics.wait;
var Atomics_wake = Atomics.wake;
var Atomics_wakeOrRequeue = Atomics.wakeOrRequeue;
var Atomics_isLockFree = Atomics.isLockFree;
var Atomics_load = Atomics.load;
var Atomics_or = Atomics.or;
var Atomics_store = Atomics.store;
var Atomics_sub = Atomics.sub;
var Atomics_xor = Atomics.xor;

function load1(ptr) { return HEAP8[ptr>>2]; }
function store1(ptr, value) { HEAP8[ptr>>2] = value; }
function load2(ptr) { return HEAP16[ptr>>2]; }
function store2(ptr, value) { HEAP16[ptr>>2] = value; }
function load4(ptr) { return HEAP32[ptr>>2]; }
function store4(ptr, value) { HEAP32[ptr>>2] = value; }

var ENVIRONMENT_IS_FETCH_WORKER = true;
var ENVIRONMENT_IS_WORKER = true;
var ENVIRONMENT_IS_PTHREAD = true;
var __pthread_is_main_runtime_thread=0;
var DYNAMICTOP_PTR = 0;
var nan = NaN;
var inf = Infinity;

function _emscripten_asm_const_v() {}

function assert(condition) {
  if (!condition) console.error('assert failure!');
}

Fetch.staticInit();

var queuePtr = 0;
var buffer = null;
var STACKTOP = 0;
var STACK_MAX = 0;
var HEAP8 = null;
var HEAPU8 = null;
var HEAP16 = null;
var HEAPU16 = null;
var HEAP32 = null;
var HEAPU32 = null;

function processWorkQueue() {
  if (!queuePtr) return;
  var numQueuedItems = Atomics_load(HEAPU32, queuePtr + 4 >> 2);
  if (numQueuedItems == 0) return;

  var queuedOperations = Atomics_load(HEAPU32, queuePtr >> 2);
  var queueSize = Atomics_load(HEAPU32, queuePtr + 8 >> 2);
  for(var i = 0; i < numQueuedItems; ++i) {
    var fetch = Atomics_load(HEAPU32, (queuedOperations >> 2)+i);
    function successcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + 108 >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + 108 >> 2, 1);
    }
    function errorcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + 108 >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + 108 >> 2, 1);
    }
    function progresscb(fetch) {
    }
    try {
      emscripten_start_fetch(fetch, successcb, errorcb, progresscb);
    } catch(e) {
      console.error(e);
    }
    /*
    if (interval != undefined) {
      clearInterval(interval);
      interval = undefined;
    }
    */
  }
  Atomics_store(HEAPU32, queuePtr + 4 >> 2, 0);
}

interval = 0;
this.onmessage = function(e) {
  if (e.data.cmd == 'init') {
    queuePtr = e.data.queuePtr;
    buffer = e.data.buffer;
    STACKTOP = e.data.STACKTOP;
    STACK_MAX = e.data.STACK_MAX;
    DYNAMICTOP_PTR = e.data.DYNAMICTOP_PTR;
    HEAP8 = new Int8Array(buffer);
    HEAPU8 = new Uint8Array(buffer);
    HEAP16 = new Int16Array(buffer);
    HEAPU16 = new Uint16Array(buffer);
    HEAP32 = new Int32Array(buffer);
    HEAPU32 = new Uint32Array(buffer);
    interval = setInterval(processWorkQueue, 100);
  }
}


